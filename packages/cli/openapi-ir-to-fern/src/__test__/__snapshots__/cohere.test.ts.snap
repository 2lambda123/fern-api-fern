// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`open api parser cohere simple 1`] = `
{
  "definitionFiles": {
    "connectors.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "endpoints": {
          "create": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Create a Connector",
            "docs": "Creates a new connector. The connector is tested during registration and will cancel registration when the test is unsuccessful. See ['Creating and Deploying a Connector'](https://docs.cohere.com/docs/creating-and-deploying-a-connector) for more information.",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "request": {
                  "name": "string",
                  "oauth": {},
                  "service_auth": {
                    "token": "string",
                    "type": "bearer",
                  },
                  "url": "string",
                },
                "response": {
                  "body": {
                    "connector": {
                      "auth_status": "valid",
                      "created_at": "2024-01-15T09:30:00Z",
                      "id": "string",
                      "name": "string",
                      "oauth": {
                        "authorize_url": "string",
                        "token_url": "string",
                      },
                      "updated_at": "2024-01-15T09:30:00Z",
                    },
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')
created_connector = co.create_connector(
  name="Example connector",
  url="https://connector-example.com/search",
)
print(created_connector)",
                    "docs": undefined,
                    "install": "python -m pip install cohere --upgrade",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const connector = await cohere.connectors.create({
    name: "test-connector",
    url: "https://example.com/search",
    description: "A test connector"
  });

  console.log(connector);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl --request POST \\
  --url https://api.cohere.ai/v1/connectors \\
  --header 'accept: application/json' \\
  --header 'content-type: application/json' \\
  --header 'Authorization: Bearer <<apiKey>>' \\
  --data '
{
  "name": "Example connector",
  "url": "https://connector-example.com/search"
}
'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "Curl",
                  },
                ],
              },
            ],
            "method": "POST",
            "path": "/v1/connectors",
            "request": {
              "body": {
                "properties": {
                  "active": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "Whether the connector is active or not.",
                    "type": "optional<boolean>",
                  },
                  "continue_on_failure": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "Whether a chat request should continue or not if the request to this connector fails.",
                    "type": "optional<boolean>",
                  },
                  "description": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "A description of the connector.",
                    "type": "optional<string>",
                  },
                  "excludes": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "A list of fields to exclude from the prompt (fields remain in the document).",
                    "type": "optional<list<string>>",
                  },
                  "name": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "A human-readable name for the connector.",
                    "type": "string",
                  },
                  "oauth": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "The OAuth 2.0 configuration for the connector. Cannot be specified if service_auth is specified.",
                    "type": "optional<root.CreateConnectorOAuth>",
                  },
                  "service_auth": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "The service to service authentication configuration for the connector. Cannot be specified if oauth is specified.",
                    "type": "optional<root.CreateConnectorServiceAuth>",
                  },
                  "url": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "The URL of the connector that will be used to search for documents.",
                    "type": "string",
                  },
                },
              },
              "headers": undefined,
              "name": "CreateConnectorRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "OK",
              "type": "root.CreateConnectorResponse",
            },
          },
          "delete": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Delete a Connector",
            "docs": "Delete a connector by ID. See ['Connectors'](https://docs.cohere.com/docs/connectors) for more information.",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.NotFoundError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "string",
                },
                "response": {
                  "body": {
                    "string": {},
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  await cohere.connectors.delete("connector-id");
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')
co.delete_connector("test-id")",
                    "docs": undefined,
                    "install": "python -m pip install cohere --upgrade",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                ],
              },
            ],
            "method": "DELETE",
            "path": "/v1/connectors/{id}",
            "path-parameters": {
              "id": {
                "docs": "The ID of the connector to delete.",
                "type": "string",
              },
            },
            "response": {
              "docs": "OK",
              "type": "root.DeleteConnectorResponse",
            },
          },
          "get": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Get a Connector",
            "docs": "Retrieve a connector by ID. See ['Connectors'](https://docs.cohere.com/docs/connectors) for more information.",
            "errors": [
              "root.BadRequestError",
              "root.NotFoundError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "string",
                },
                "response": {
                  "body": {
                    "connector": {
                      "auth_status": "valid",
                      "created_at": "2024-01-15T09:30:00Z",
                      "id": "string",
                      "name": "string",
                      "oauth": {
                        "authorize_url": "string",
                        "token_url": "string",
                      },
                      "updated_at": "2024-01-15T09:30:00Z",
                    },
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')
connector = co.get_connector("test-id")
print(connector)",
                    "docs": undefined,
                    "install": "python -m pip install cohere --upgrade",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const connector = await cohere.connectors.get("connector-id");

  console.log(connector);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                ],
              },
            ],
            "method": "GET",
            "path": "/v1/connectors/{id}",
            "path-parameters": {
              "id": {
                "docs": "The ID of the connector to retrieve.",
                "type": "string",
              },
            },
            "response": {
              "docs": "OK",
              "type": "root.GetConnectorResponse",
            },
          },
          "list": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "List Connectors",
            "docs": "Returns a list of connectors ordered by descending creation date (newer first). See ['Managing your Connector'](https://docs.cohere.com/docs/managing-your-connector) for more information.",
            "errors": [
              "root.BadRequestError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "response": {
                  "body": {
                    "connectors": [],
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')
connectors = co.list_connectors()
print(connectors)",
                    "docs": undefined,
                    "install": "python -m pip install cohere --upgrade",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const connectors = await cohere.connectors.list();

  console.log(connectors);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                ],
              },
            ],
            "method": "GET",
            "path": "/v1/connectors",
            "request": {
              "name": "ConnectorsListRequest",
              "query-parameters": {
                "limit": {
                  "docs": "Maximum number of connectors to return [0, 100].",
                  "type": "optional<double>",
                },
                "offset": {
                  "docs": "Number of connectors to skip before returning results [0, inf].",
                  "type": "optional<double>",
                },
              },
            },
            "response": {
              "docs": "OK",
              "type": "root.ListConnectorsResponse",
            },
          },
          "oAuthAuthorize": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Authorize with oAuth",
            "docs": "Authorize the connector with the given ID for the connector oauth app.  See ['Connector Authentication'](https://docs.cohere.com/docs/connector-authentication) for more information.",
            "errors": [
              "root.BadRequestError",
              "root.NotFoundError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "string",
                },
                "response": {
                  "body": {},
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')
redirect_url = co.oauth_authorize_connector(connector_id="test-id", after_token_redirect="https://test.com")
print(redirect_url)",
                    "docs": undefined,
                    "install": "python -m pip install cohere --upgrade",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const connector = await cohere.connectors.oAuthAuthorize("connector-id", {
    redirect_uri: "https://example.com/oauth/callback",
  });

  console.log(connector);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                ],
              },
            ],
            "method": "POST",
            "path": "/v1/connectors/{id}/oauth/authorize",
            "path-parameters": {
              "id": {
                "docs": "The ID of the connector to authorize.",
                "type": "string",
              },
            },
            "request": {
              "name": "ConnectorsOAuthAuthorizeRequest",
              "query-parameters": {
                "after_token_redirect": {
                  "docs": "The URL to redirect to after the connector has been authorized.",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "OK",
              "type": "root.OAuthAuthorizeResponse",
            },
          },
          "update": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Update a Connector",
            "docs": "Update a connector by ID. Omitted fields will not be updated. See ['Managing your Connector'](https://docs.cohere.com/docs/managing-your-connector) for more information.",
            "errors": [
              "root.BadRequestError",
              "root.ForbiddenError",
              "root.NotFoundError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "string",
                },
                "request": {
                  "oauth": {},
                  "service_auth": {
                    "token": "string",
                    "type": "bearer",
                  },
                },
                "response": {
                  "body": {
                    "connector": {
                      "auth_status": "valid",
                      "created_at": "2024-01-15T09:30:00Z",
                      "id": "string",
                      "name": "string",
                      "oauth": {
                        "authorize_url": "string",
                        "token_url": "string",
                      },
                      "updated_at": "2024-01-15T09:30:00Z",
                    },
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')
updated_connector = co.update_connector(connector_id="test-id", name="new name", url="https://example.com/search")
print(updated_connector)",
                    "docs": undefined,
                    "install": "python -m pip install cohere --upgrade",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const connector = await cohere.connectors.update(connector.id, {
    name: "test-connector-renamed",
    description: "A test connector renamed"
  });

  console.log(connector);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl --request PATCH \\
  --url https://api.cohere.ai/v1/connectors/id \\
  --header 'accept: application/json' \\
  --header 'content-type: application/json' \\
  --header 'Authorization: Bearer <<apiKey>>' \\
  --data '
{
  "name": "new name",
  "url": "https://example.com/search"
}
'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "Curl",
                  },
                ],
              },
            ],
            "method": "PATCH",
            "path": "/v1/connectors/{id}",
            "path-parameters": {
              "id": {
                "docs": "The ID of the connector to update.",
                "type": "string",
              },
            },
            "request": {
              "body": {
                "properties": {
                  "active": {
                    "audiences": [
                      "public",
                    ],
                    "docs": undefined,
                    "type": "optional<boolean>",
                  },
                  "continue_on_failure": {
                    "audiences": [
                      "public",
                    ],
                    "docs": undefined,
                    "type": "optional<boolean>",
                  },
                  "excludes": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "A list of fields to exclude from the prompt (fields remain in the document).",
                    "type": "optional<list<string>>",
                  },
                  "name": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "A human-readable name for the connector.",
                    "type": "optional<string>",
                  },
                  "oauth": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "The OAuth 2.0 configuration for the connector. Cannot be specified if service_auth is specified.",
                    "type": "optional<root.CreateConnectorOAuth>",
                  },
                  "service_auth": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "The service to service authentication configuration for the connector. Cannot be specified if oauth is specified.",
                    "type": "optional<root.CreateConnectorServiceAuth>",
                  },
                  "url": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "The URL of the connector that will be used to search for documents.",
                    "type": "optional<string>",
                  },
                },
              },
              "headers": undefined,
              "name": "UpdateConnectorRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "OK",
              "type": "root.UpdateConnectorResponse",
            },
          },
        },
      },
    },
    "datasets.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "endpoints": {
          "create": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Create a Dataset",
            "docs": "Create a dataset by uploading a file. See ['Dataset Creation'](https://docs.cohere.com/docs/datasets#dataset-creation) for more information.",
            "examples": [
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# upload a dataset
my_dataset = co.create_dataset(
  name="prompt-completion-dataset",
  data=open("./prompt-completion.jsonl", "rb"),
  dataset_type="prompt-completion-finetune-input")

# wait for validation to complete
my_dataset.await_validation()

print(my_dataset)",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");
const fs = require("fs");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const file = fs.createReadStream("embed_jobs_sample_data.jsonl") // {"text": "The quick brown fox jumps over the lazy dog"}

  const dataset = await cohere.datasets.create(
      { name: "my-dataset", type: "embed-input" },
      file,
  );

  console.log(dataset);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl
  --request POST \\
  --url 'https://api.cohere.ai/v1/datasets?name=my-dataset&type=generative-finetune-input' \\
  --header 'Authorization: bearer <<apiKey>>' \\
  --header 'Content-Type: multipart/form-data' \\
  --form file=@/path/to/file.jsonl",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "POST",
            "path": "/v1/datasets",
            "request": {
              "body": {
                "properties": {
                  "data": "file",
                  "eval_data": "file",
                },
              },
              "headers": undefined,
              "name": "DatasetsCreateRequest",
              "query-parameters": {
                "csv_delimiter": {
                  "docs": "The delimiter used for .csv uploads.",
                  "type": "optional<string>",
                },
                "keep_fields": {
                  "allow-multiple": true,
                  "docs": "List of names of fields that will be persisted in the Dataset. By default the Dataset will retain only the required fields indicated in the [schema for the corresponding Dataset type](https://docs.cohere.com/docs/datasets#dataset-types). For example, datasets of type \`embed-input\` will drop all fields other than the required \`text\` field. If any of the fields in \`keep_fields\` are missing from the uploaded file, Dataset validation will fail.",
                  "type": "optional<string>",
                },
                "keep_original_file": {
                  "docs": "Indicates if the original file should be stored.",
                  "type": "optional<boolean>",
                },
                "name": {
                  "docs": "The name of the uploaded dataset.",
                  "type": "optional<string>",
                },
                "optional_fields": {
                  "allow-multiple": true,
                  "docs": "List of names of fields that will be persisted in the Dataset. By default the Dataset will retain only the required fields indicated in the [schema for the corresponding Dataset type](https://docs.cohere.com/docs/datasets#dataset-types). For example, Datasets of type \`embed-input\` will drop all fields other than the required \`text\` field. If any of the fields in \`optional_fields\` are missing from the uploaded file, Dataset validation will pass.",
                  "type": "optional<string>",
                },
                "skip_malformed_input": {
                  "docs": "Indicates whether rows with malformed input should be dropped (instead of failing the validation check). Dropped rows will be returned in the warnings field.",
                  "type": "optional<boolean>",
                },
                "text_separator": {
                  "docs": "Raw .txt uploads will be split into entries using the text_separator value.",
                  "type": "optional<string>",
                },
                "type": {
                  "docs": "The dataset type, which is used to validate the data.",
                  "type": "optional<root.DatasetType>",
                },
              },
            },
            "response": {
              "docs": "A successful response.",
              "type": "DatasetsCreateResponse",
            },
          },
          "delete": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Delete a Dataset",
            "docs": "Delete a dataset by ID. Datasets are automatically deleted after 30 days, but they can also be deleted manually.",
            "examples": [
              {
                "path-parameters": {
                  "id": "string",
                },
                "response": {
                  "body": {
                    "string": {},
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# delete dataset
co.delete_dataset('id')",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "curl
  --request DELETE \\
  --url 'https://api.cohere.ai/v1/datasets/{id}' \\
  --header 'Authorization: bearer <<apiKey>>'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "DELETE",
            "path": "/v1/datasets/{id}",
            "path-parameters": {
              "id": "string",
            },
            "response": {
              "docs": "A successful response.",
              "type": "map<string, unknown>",
            },
          },
          "get": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Get a Dataset",
            "docs": "Retrieve a dataset by ID. See ['Datasets'](https://docs.cohere.com/docs/datasets) for more information.",
            "examples": [
              {
                "path-parameters": {
                  "id": "string",
                },
                "response": {
                  "body": {
                    "dataset": {
                      "created_at": "2024-01-15T09:30:00Z",
                      "dataset_type": "embed-input",
                      "id": "string",
                      "name": "string",
                      "parse_info": {},
                      "updated_at": "2024-01-15T09:30:00Z",
                      "validation_status": "unknown",
                    },
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# get dataset
my_dataset = co.get_dataset('id')

print(my_dataset)",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const dataset = await cohere.datasets.get("id");

  console.log(dataset);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl
  --request GET \\
  --url 'https://api.cohere.ai/v1/datasets/{id}' \\
  --header 'Authorization: bearer <<apiKey>>'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "GET",
            "path": "/v1/datasets/{id}",
            "path-parameters": {
              "id": "string",
            },
            "response": {
              "docs": "A successful response.",
              "type": "DatasetsGetResponse",
            },
          },
          "getUsage": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Get Dataset Usage",
            "docs": "View the dataset storage usage for your Organization. Each Organization can have up to 10GB of storage across all their users.",
            "examples": [
              {
                "response": {
                  "body": {},
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# get usage
dataset_usage = co.get_dataset_usage()

print(dataset_usage)",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const usage = await cohere.datasets.getUsage("id");

  console.log(usage);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl
  --request GET \\
  --url 'https://api.cohere.ai/v1/datasets/usage' \\
  --header 'Authorization: bearer <<apiKey>>'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "GET",
            "path": "/v1/datasets/usage",
            "response": {
              "docs": "A successful response.",
              "type": "DatasetsGetUsageResponse",
            },
          },
          "list": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "List Datasets",
            "docs": "List datasets that have been created.",
            "examples": [
              {
                "response": {
                  "body": {},
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# list datasets
my_datasets = co.list_datasets()

print(my_datasets)",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const datasets = await cohere.datasets.list();

  console.log(datasets);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl
  --request GET \\
  --url 'https://api.cohere.ai/v1/datasets' \\
  --header 'Authorization: bearer <<apiKey>>'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "GET",
            "path": "/v1/datasets",
            "request": {
              "name": "DatasetsListRequest",
              "query-parameters": {
                "after": {
                  "docs": "optional filter after a date",
                  "type": "optional<datetime>",
                },
                "before": {
                  "docs": "optional filter before a date",
                  "type": "optional<datetime>",
                },
                "datasetType": {
                  "docs": "optional filter by dataset type",
                  "type": "optional<string>",
                },
                "limit": {
                  "docs": "optional limit to number of results",
                  "type": "optional<string>",
                },
                "offset": {
                  "docs": "optional offset to start of results",
                  "type": "optional<string>",
                },
              },
            },
            "response": {
              "docs": "A successful response.",
              "type": "DatasetsListResponse",
            },
          },
        },
      },
      "types": {
        "DatasetsCreateResponse": {
          "docs": undefined,
          "properties": {
            "id": {
              "audiences": [
                "public",
              ],
              "docs": "The dataset ID",
              "type": "optional<string>",
            },
          },
        },
        "DatasetsGetResponse": {
          "docs": undefined,
          "properties": {
            "dataset": "root.Dataset",
          },
        },
        "DatasetsGetUsageResponse": {
          "docs": undefined,
          "properties": {
            "organization_usage": {
              "audiences": [
                "public",
              ],
              "docs": "The total number of bytes used by the organization.",
              "type": "optional<string>",
            },
          },
        },
        "DatasetsListResponse": {
          "docs": undefined,
          "properties": {
            "datasets": {
              "audiences": [
                "public",
              ],
              "type": "optional<list<root.Dataset>>",
            },
          },
        },
      },
    },
    "embedJobs.yml": {
      "imports": {
        "root": "__package__.yml",
      },
      "service": {
        "auth": false,
        "base-path": "",
        "endpoints": {
          "cancel": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Cancel an Embed Job",
            "docs": "This API allows users to cancel an active embed job. Once invoked, the embedding process will be terminated, and users will be charged for the embeddings processed up to the cancellation point. It's important to note that partial results will not be available to users after cancellation.",
            "errors": [
              "root.BadRequestError",
              "root.NotFoundError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "string",
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# cancel an embed job
co.cancel_embed_job('job_id')",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const embedJob = await cohere.embedJobs.cancel("job_id");

  console.log(embedJob);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl
  --request POST \\
  --url https://api.cohere.ai/v1/embed-jobs/{id}/cancel \\
  --header 'Authorization: bearer <<apiKey>>'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "POST",
            "path": "/v1/embed-jobs/{id}/cancel",
            "path-parameters": {
              "id": {
                "docs": "The ID of the embed job to cancel.",
                "type": "string",
              },
            },
          },
          "create": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Create an Embed Job",
            "docs": "This API launches an async Embed job for a [Dataset](https://docs.cohere.com/docs/datasets) of type \`embed-input\`. The result of a completed embed job is new Dataset of type \`embed-output\`, which contains the original text entries and the corresponding embeddings.",
            "errors": [
              "root.BadRequestError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "request": {
                  "dataset_id": "string",
                  "input_type": "search_document",
                  "model": "string",
                  "truncate": "START",
                },
                "response": {
                  "body": {
                    "job_id": "string",
                    "meta": {
                      "api_version": {
                        "version": "string",
                      },
                      "billed_units": {},
                    },
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# start an embed job
job = co.create_embed_job(
dataset_id=ds.id,
input_type='search_document',
model='embed-english-v3.0')

# poll the server until the job is complete
job.wait()

print(job)",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const embedJob = await cohere.embedJobs.create({
      datasetId: "my-dataset",
      inputType: "search_document",
      model: "embed-english-v3.0",
  });

  console.log(embedJob);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl --request POST \\
  --url https://api.cohere.ai/v1/embed-jobs \\
  --header 'Authorization: bearer <<apiKey>>' \\
  --data '
  {
    "model": "embed-english-v3.0",
    "dataset_id": "my-dataset"
  }
  '",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "POST",
            "path": "/v1/embed-jobs",
            "request": {
              "body": {
                "properties": {
                  "dataset_id": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "ID of a [Dataset](https://docs.cohere.com/docs/datasets). The Dataset must be of type \`embed-input\` and must have a validation status \`Validated\`",
                    "type": "string",
                  },
                  "input_type": {
                    "audiences": [
                      "public",
                    ],
                    "docs": undefined,
                    "type": "root.EmbedInputType",
                  },
                  "model": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "ID of the embedding model.

Available models and corresponding embedding dimensions:

- \`embed-english-v3.0\` : 1024
- \`embed-multilingual-v3.0\` : 1024
- \`embed-english-light-v3.0\` : 384
- \`embed-multilingual-light-v3.0\` : 384
",
                    "type": "string",
                  },
                  "name": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "The name of the embed job.",
                    "type": "optional<string>",
                  },
                  "truncate": {
                    "audiences": [
                      "public",
                    ],
                    "docs": "One of \`START|END\` to specify how the API will handle inputs longer than the maximum token length.

Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
",
                    "type": "optional<CreateEmbedJobRequestTruncate>",
                  },
                },
              },
              "headers": undefined,
              "name": "CreateEmbedJobRequest",
              "query-parameters": undefined,
            },
            "response": {
              "docs": "OK",
              "type": "root.CreateEmbedJobResponse",
            },
          },
          "get": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "Fetch an Embed Job",
            "docs": "This API retrieves the details about an embed job started by the same user.",
            "errors": [
              "root.BadRequestError",
              "root.NotFoundError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "path-parameters": {
                  "id": "string",
                },
                "response": {
                  "body": {
                    "created_at": "2024-01-15T09:30:00Z",
                    "input_dataset_id": "string",
                    "job_id": "string",
                    "meta": {
                      "api_version": {
                        "version": "string",
                      },
                      "billed_units": {},
                    },
                    "model": "string",
                    "status": "processing",
                    "truncate": "START",
                  },
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# get embed job
my_embed_job = co.get_embed_job('job_id')

print(my_embed_job)",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const embedJob = await cohere.embedJobs.get("job_id");

  console.log(embedJob);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl
  --request GET \\
  --url https://api.cohere.ai/v1/embed-jobs/{id} \\
  --header 'Authorization: bearer <<apiKey>>'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "GET",
            "path": "/v1/embed-jobs/{id}",
            "path-parameters": {
              "id": {
                "docs": "The ID of the embed job to retrieve.",
                "type": "string",
              },
            },
            "response": {
              "docs": "OK",
              "type": "root.EmbedJob",
            },
          },
          "list": {
            "audiences": [
              "public",
            ],
            "auth": true,
            "display-name": "List Embed Jobs",
            "docs": "The list embed job endpoint allows users to view all embed jobs history for that specific user.",
            "errors": [
              "root.BadRequestError",
              "root.InternalServerError",
            ],
            "examples": [
              {
                "response": {
                  "body": {},
                },
              },
              {
                "code-samples": [
                  {
                    "code": "import cohere
co = cohere.Client('<<apiKey>>')

# list embed jobs
my_embed_jobs = co.list_embed_jobs()

print(my_embed_jobs)",
                    "docs": undefined,
                    "install": "python -m pip install cohere",
                    "language": "python",
                    "name": "Cohere Python SDK",
                  },
                  {
                    "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const embedJobs = await cohere.embedJobs.list();

  console.log(embedJobs);
})();",
                    "docs": undefined,
                    "install": "npm i cohere-ai",
                    "language": "node",
                    "name": "Cohere TypeScript SDK",
                  },
                  {
                    "code": "curl --request GET \\
  --url https://api.cohere.ai/v1/embed-jobs \\
  --header 'Authorization: bearer <<apiKey>>'",
                    "docs": undefined,
                    "install": undefined,
                    "language": "curl",
                    "name": "cURL",
                  },
                ],
              },
            ],
            "method": "GET",
            "path": "/v1/embed-jobs",
            "response": {
              "docs": "OK",
              "type": "root.ListEmbedJobResponse",
            },
          },
        },
      },
      "types": {
        "CreateEmbedJobRequestTruncate": {
          "docs": "One of \`START|END\` to specify how the API will handle inputs longer than the maximum token length.

Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
",
          "enum": [
            "START",
            "END",
          ],
        },
      },
    },
  },
  "packageMarkerFile": {
    "errors": {
      "BadRequestError": {
        "status-code": 400,
        "type": "unknown",
      },
      "ForbiddenError": {
        "status-code": 403,
        "type": "unknown",
      },
      "InternalServerError": {
        "status-code": 500,
        "type": "unknown",
      },
      "NotFoundError": {
        "status-code": 404,
        "type": "unknown",
      },
    },
    "service": {
      "auth": false,
      "base-path": "",
      "endpoints": {
        "chat": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Chat (Beta)",
          "docs": "The \`chat\` endpoint allows users to have conversations with a Large Language Model (LLM) from Cohere. Users can send messages as part of a persisted conversation using the \`conversation_id\` parameter, or they can pass in their own conversation history using the \`chat_history\` parameter.

The endpoint features additional parameters such as [connectors](https://docs.cohere.com/docs/connectors) and \`documents\` that enable conversations enriched by external knowledge. We call this ["Retrieval Augmented Generation"](https://docs.cohere.com/docs/retrieval-augmented-generation-rag), or "RAG". For a full breakdown of the Chat API endpoint, document and connector modes, and streaming (with code samples), see [this guide](https://docs.cohere.com/docs/cochat-beta).
",
          "examples": [
            {
              "name": "Chat",
              "request": {
                "chat_history": [
                  {
                    "message": "Hi!",
                    "role": "CHATBOT",
                  },
                  {
                    "message": "How can I help you today?",
                    "role": "CHATBOT",
                  },
                ],
                "citation_quality": "fast",
                "message": "Can you give me a global market overview of solar panels?",
                "prompt_truncation": "OFF",
                "stream": false,
                "temperature": 0.3,
              },
              "response": {
                "body": {
                  "generation_id": "string",
                  "text": "string",
                },
              },
            },
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const chatStream = await cohere.chatStream({
      chatHistory: [
          { role: "USER", message: "Who discovered gravity?" },
          { role: "CHATBOT", message: "The man who is widely credited with discovering gravity is Sir Isaac Newton" }
      ],
      message: "What year was he born?",
      // perform web search before answering the question. You can also use your own custom connector.
      connectors: [{ id: "web-search" }],
  });

  for await (const message of chatStream) {
      if (message.eventType === "text-generation") {
          console.log(message);
      }
  }
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')
response = co.chat(
  chat_history=[
    {"role": "USER", "message": "Who discovered gravity?"},
    {"role": "CHATBOT", "message": "The man who is widely credited with discovering gravity is Sir Isaac Newton"}
  ],
  message="What year was he born?",
  # perform web search before answering the question. You can also use your own custom connector.
  connectors=[{"id": "web-search"}]
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
                {
                  "code": "curl
  --request POST \\
  --url https://api.cohere.ai/v1/chat \\
  --header 'accept: application/json' \\
  --header 'content-type: application/json' \\
  --header 'Authorization: Bearer <<apiKey>>'
  --data '
  {
    "chat_history": [
      {"role": "USER", "message": "Who discovered gravity?"},
      {"role": "CHATBOT", "message": "The man who is widely credited with discovering gravity is Sir Isaac Newton"}
    ],
    "message": "What year was he born?",
    "connectors": [{"id": "web-search"}]
  }'",
                  "docs": undefined,
                  "install": undefined,
                  "language": "curl",
                  "name": "cURL",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/chat",
          "request": {
            "body": {
              "properties": {
                "chat_history": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's \`message\`.
",
                  "type": "optional<list<ChatMessage>>",
                },
                "citation_quality": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`"accurate"\`.

Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want \`"accurate"\` results or \`"fast"\` results.
",
                  "type": "optional<ChatRequestCitationQuality>",
                },
                "connectors": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Accepts \`{"id": "web-search"}\`, and/or the \`"id"\` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.

When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).
",
                  "type": "optional<list<ChatConnector>>",
                },
                "conversation_id": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "An alternative to \`chat_history\`. Previous conversations can be resumed by providing the conversation's identifier. The contents of \`message\` and the model's response will be stored as part of this conversation.

If a conversation with this id does not already exist, a new conversation will be created.
",
                  "type": "optional<string>",
                },
                "documents": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A list of relevant documents that the model can use to enrich its reply. See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.
",
                  "type": "optional<list<ChatDocument>>",
                },
                "frequency_penalty": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
",
                  "type": "optional<double>",
                },
                "k": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ensures only the top \`k\` most likely tokens are considered for generation at each step.
Defaults to \`0\`, min value of \`0\`, max value of \`500\`.
",
                  "type": "optional<integer>",
                },
                "max_tokens": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
",
                  "type": "optional<integer>",
                },
                "message": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Accepts a string.
The chat message from the user to the model.
",
                  "type": "string",
                },
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`command\`.

The identifier of the model, which can be one of the existing Cohere models or the full ID for a [fine-tuned custom model](https://docs.cohere.com/docs/chat-fine-tuning).

Compatible Cohere models are \`command\` and \`command-light\` as well as the experimental \`command-nightly\` and \`command-light-nightly\` variants. Read more about [Cohere models](https://docs.cohere.com/docs/models).
",
                  "type": "optional<string>",
                },
                "p": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ensures that only the most likely tokens, with total probability mass of \`p\`, are considered for generation at each step. If both \`k\` and \`p\` are enabled, \`p\` acts after \`k\`.
Defaults to \`0.75\`. min value of \`0.01\`, max value of \`0.99\`.
",
                  "type": "optional<double>",
                },
                "preamble_override": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "When specified, the default Cohere preamble will be replaced with the provided one.
",
                  "type": "optional<string>",
                },
                "presence_penalty": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`0.0\`, min value of \`0.0\`, max value of \`1.0\`. Can be used to reduce repetitiveness of generated tokens. Similar to \`frequency_penalty\`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.",
                  "type": "optional<double>",
                },
                "prompt_truncation": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`AUTO\` when \`connectors\` are specified and \`OFF\` in all other cases.

Dictates how the prompt will be constructed.

With \`prompt_truncation\` set to "AUTO", some elements from \`chat_history\` and \`documents\` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.

With \`prompt_truncation\` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a \`TooManyTokens\` error will be returned.
",
                  "type": "optional<ChatRequestPromptTruncation>",
                },
                "search_queries_only": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`false\`.

When \`true\`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's \`message\` will be generated.
",
                  "type": "optional<boolean>",
                },
                "stream": {
                  "audiences": [
                    "public",
                  ],
                  "docs": undefined,
                  "type": "literal<false>",
                },
                "temperature": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`0.3\`.

A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.

Randomness can be further maximized by increasing the  value of the \`p\` parameter.
",
                  "type": "optional<double>",
                },
              },
            },
            "headers": undefined,
            "name": "ChatRequest",
            "query-parameters": undefined,
          },
          "response": {
            "docs": "",
            "type": "ChatResponse",
          },
        },
        "chat_stream": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Chat (Beta)",
          "docs": "The \`chat\` endpoint allows users to have conversations with a Large Language Model (LLM) from Cohere. Users can send messages as part of a persisted conversation using the \`conversation_id\` parameter, or they can pass in their own conversation history using the \`chat_history\` parameter.

The endpoint features additional parameters such as [connectors](https://docs.cohere.com/docs/connectors) and \`documents\` that enable conversations enriched by external knowledge. We call this ["Retrieval Augmented Generation"](https://docs.cohere.com/docs/retrieval-augmented-generation-rag), or "RAG". For a full breakdown of the Chat API endpoint, document and connector modes, and streaming (with code samples), see [this guide](https://docs.cohere.com/docs/cochat-beta).
",
          "examples": [
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const chatStream = await cohere.chatStream({
      chatHistory: [
          { role: "USER", message: "Who discovered gravity?" },
          { role: "CHATBOT", message: "The man who is widely credited with discovering gravity is Sir Isaac Newton" }
      ],
      message: "What year was he born?",
      // perform web search before answering the question. You can also use your own custom connector.
      connectors: [{ id: "web-search" }],
  });

  for await (const message of chatStream) {
      if (message.eventType === "text-generation") {
          console.log(message);
      }
  }
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')
response = co.chat(
  chat_history=[
    {"role": "USER", "message": "Who discovered gravity?"},
    {"role": "CHATBOT", "message": "The man who is widely credited with discovering gravity is Sir Isaac Newton"}
  ],
  message="What year was he born?",
  # perform web search before answering the question. You can also use your own custom connector.
  connectors=[{"id": "web-search"}]
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
                {
                  "code": "curl
  --request POST \\
  --url https://api.cohere.ai/v1/chat \\
  --header 'accept: application/json' \\
  --header 'content-type: application/json' \\
  --header 'Authorization: Bearer <<apiKey>>'
  --data '
  {
    "chat_history": [
      {"role": "USER", "message": "Who discovered gravity?"},
      {"role": "CHATBOT", "message": "The man who is widely credited with discovering gravity is Sir Isaac Newton"}
    ],
    "message": "What year was he born?",
    "connectors": [{"id": "web-search"}]
  }'",
                  "docs": undefined,
                  "install": undefined,
                  "language": "curl",
                  "name": "cURL",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/chat",
          "request": {
            "body": {
              "properties": {
                "chat_history": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's \`message\`.
",
                  "type": "optional<list<ChatMessage>>",
                },
                "citation_quality": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`"accurate"\`.

Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want \`"accurate"\` results or \`"fast"\` results.
",
                  "type": "optional<ChatStreamRequestCitationQuality>",
                },
                "connectors": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Accepts \`{"id": "web-search"}\`, and/or the \`"id"\` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.

When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).
",
                  "type": "optional<list<ChatConnector>>",
                },
                "conversation_id": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "An alternative to \`chat_history\`. Previous conversations can be resumed by providing the conversation's identifier. The contents of \`message\` and the model's response will be stored as part of this conversation.

If a conversation with this id does not already exist, a new conversation will be created.
",
                  "type": "optional<string>",
                },
                "documents": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A list of relevant documents that the model can use to enrich its reply. See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.
",
                  "type": "optional<list<ChatDocument>>",
                },
                "frequency_penalty": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
",
                  "type": "optional<double>",
                },
                "k": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ensures only the top \`k\` most likely tokens are considered for generation at each step.
Defaults to \`0\`, min value of \`0\`, max value of \`500\`.
",
                  "type": "optional<integer>",
                },
                "max_tokens": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
",
                  "type": "optional<integer>",
                },
                "message": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Accepts a string.
The chat message from the user to the model.
",
                  "type": "string",
                },
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`command\`.

The identifier of the model, which can be one of the existing Cohere models or the full ID for a [fine-tuned custom model](https://docs.cohere.com/docs/chat-fine-tuning).

Compatible Cohere models are \`command\` and \`command-light\` as well as the experimental \`command-nightly\` and \`command-light-nightly\` variants. Read more about [Cohere models](https://docs.cohere.com/docs/models).
",
                  "type": "optional<string>",
                },
                "p": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ensures that only the most likely tokens, with total probability mass of \`p\`, are considered for generation at each step. If both \`k\` and \`p\` are enabled, \`p\` acts after \`k\`.
Defaults to \`0.75\`. min value of \`0.01\`, max value of \`0.99\`.
",
                  "type": "optional<double>",
                },
                "preamble_override": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "When specified, the default Cohere preamble will be replaced with the provided one.
",
                  "type": "optional<string>",
                },
                "presence_penalty": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`0.0\`, min value of \`0.0\`, max value of \`1.0\`. Can be used to reduce repetitiveness of generated tokens. Similar to \`frequency_penalty\`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.",
                  "type": "optional<double>",
                },
                "prompt_truncation": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`AUTO\` when \`connectors\` are specified and \`OFF\` in all other cases.

Dictates how the prompt will be constructed.

With \`prompt_truncation\` set to "AUTO", some elements from \`chat_history\` and \`documents\` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.

With \`prompt_truncation\` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a \`TooManyTokens\` error will be returned.
",
                  "type": "optional<ChatStreamRequestPromptTruncation>",
                },
                "search_queries_only": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`false\`.

When \`true\`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's \`message\` will be generated.
",
                  "type": "optional<boolean>",
                },
                "stream": {
                  "audiences": [
                    "public",
                  ],
                  "docs": undefined,
                  "type": "literal<true>",
                },
                "temperature": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`0.3\`.

A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.

Randomness can be further maximized by increasing the  value of the \`p\` parameter.
",
                  "type": "optional<double>",
                },
              },
            },
            "headers": undefined,
            "name": "ChatStreamRequest",
            "query-parameters": undefined,
          },
          "response-stream": {
            "docs": "",
            "type": "ChatStreamResponse",
          },
        },
        "classify": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Classify",
          "docs": "This endpoint makes a prediction about which label fits the specified text inputs best. To make a prediction, Classify uses the provided \`examples\` of text + label pairs as a reference.
Note: [Fine-tuned models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the \`examples\` parameter to be passed in explicitly.",
          "errors": [
            "BadRequestError",
            "InternalServerError",
          ],
          "examples": [
            {
              "name": "Example",
              "request": {
                "examples": [
                  {
                    "label": "Spam",
                    "text": "Dermatologists don't like her!",
                  },
                  {
                    "label": "Spam",
                    "text": "Hello, open to this?",
                  },
                  {
                    "label": "Spam",
                    "text": "I need help please wire me $1000 right now",
                  },
                  {
                    "label": "Spam",
                    "text": "Nice to know you ;)",
                  },
                  {
                    "label": "Spam",
                    "text": "Please help me?",
                  },
                  {
                    "label": "Not spam",
                    "text": "Your parcel will be delivered today",
                  },
                  {
                    "label": "Not spam",
                    "text": "Review changes to our Terms and Conditions",
                  },
                  {
                    "label": "Not spam",
                    "text": "Weekly sync notes",
                  },
                  {
                    "label": "Not spam",
                    "text": "Re: Follow up from today’s meeting",
                  },
                  {
                    "label": "Not spam",
                    "text": "Pre-read for tomorrow",
                  },
                ],
                "inputs": [
                  "Confirm your email address",
                  "hey i need u to send some $",
                ],
                "preset": "my-preset-a58sbd",
                "truncate": "NONE",
              },
              "response": {
                "body": {
                  "classifications": [
                    {
                      "classification_type": "single-label",
                      "confidence": 0.7581943,
                      "confidences": [
                        0.7581943,
                      ],
                      "id": "c50ab0d9-95d8-44de-ba90-9647a1718744",
                      "input": "Confirm your email address",
                      "labels": {
                        "Not spam": {
                          "confidence": 0.7581943,
                        },
                        "Spam": {
                          "confidence": 0.24180566,
                        },
                      },
                      "prediction": "Not spam",
                      "predictions": [
                        "Not spam",
                      ],
                    },
                    {
                      "classification_type": "single-label",
                      "confidence": 0.9965721,
                      "confidences": [
                        0.9965721,
                      ],
                      "id": "8a841de2-027f-49d4-8c91-e88fa1865b89",
                      "input": "hey i need u to send some $",
                      "labels": {
                        "Not spam": {
                          "confidence": 0.0034279241,
                        },
                        "Spam": {
                          "confidence": 0.9965721,
                        },
                      },
                      "prediction": "Spam",
                      "predictions": [
                        "Spam",
                      ],
                    },
                  ],
                  "id": "ca245541-8841-456e-b306-293370789a30",
                  "meta": {
                    "api_version": {
                      "version": "1",
                    },
                    "billed_units": {},
                  },
                },
              },
            },
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const classify = await cohere.classify({
      examples: [
          { text: "Dermatologists don't like her!", label: "Spam" },
          { text: "'Hello, open to this?'", label: "Spam" },
          { text: "I need help please wire me $1000 right now", label: "Spam" },
          { text: "Nice to know you ;)", label: "Spam" },
          { text: "Please help me?", label: "Spam" },
          { text: "Your parcel will be delivered today", label: "Not spam" },
          { text: "Review changes to our Terms and Conditions", label: "Not spam" },
          { text: "Weekly sync notes", label: "Not spam" },
          { text: "'Re: Follow up from today's meeting'", label: "Not spam" },
          { text: "Pre-read for tomorrow", label: "Not spam" },
      ],
      inputs: [
          "Confirm your email address",
          "hey i need u to send some $",
      ],
  })

  console.log(classify);
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
from cohere.responses.classify import Example
co = cohere.Client('<<apiKey>>')
examples=[
  Example("Dermatologists don't like her!", "Spam"),
  Example("'Hello, open to this?'", "Spam"),
  Example("I need help please wire me $1000 right now", "Spam"),
  Example("Nice to know you ;)", "Spam"),
  Example("Please help me?", "Spam"),
  Example("Your parcel will be delivered today", "Not spam"),
  Example("Review changes to our Terms and Conditions", "Not spam"),
  Example("Weekly sync notes", "Not spam"),
  Example("'Re: Follow up from today's meeting'", "Not spam"),
  Example("Pre-read for tomorrow", "Not spam"),
]
inputs=[
  "Confirm your email address",
  "hey i need u to send some $",
]
response = co.classify(
  inputs=inputs,
  examples=examples,
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/classify",
          "request": {
            "body": {
              "properties": {
                "examples": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "An array of examples to provide context to the model. Each example is a text string and its associated label/class. Each unique label requires at least 2 examples associated with it; the maximum number of examples is 2500, and each example has a maximum length of 512 tokens. The values should be structured as \`{text: "...",label: "..."}\`.
Note: [Fine-tuned Models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the \`examples\` parameter to be passed in explicitly.",
                  "type": "list<ClassifyExample>",
                },
                "inputs": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A list of up to 96 texts to be classified. Each one must be a non-empty string.
There is, however, no consistent, universal limit to the length a particular input can be. We perform classification on the first \`x\` tokens of each input, and \`x\` varies depending on which underlying model is powering classification. The maximum token length for each model is listed in the "max tokens" column [here](https://docs.cohere.com/docs/models).
Note: by default the \`truncate\` parameter is set to \`END\`, so tokens exceeding the limit will be automatically dropped. This behavior can be disabled by setting \`truncate\` to \`NONE\`, which will result in validation errors for longer texts.",
                  "type": "list<string>",
                },
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The identifier of the model. Currently available models are \`embed-multilingual-v2.0\`, \`embed-english-light-v2.0\`, and \`embed-english-v2.0\` (default). Smaller "light" models are faster, while larger models will perform better. [Fine-tuned models](https://docs.cohere.com/docs/fine-tuning) can also be supplied with their full ID.",
                  "type": "optional<string>",
                },
                "preset": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The ID of a custom playground preset. You can create presets in the [playground](https://dashboard.cohere.ai/playground/classify?model=large). If you use a preset, all other parameters become optional, and any included parameters will override the preset's parameters.",
                  "type": "optional<string>",
                },
                "truncate": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`NONE|START|END\` to specify how the API will handle inputs longer than the maximum token length.
Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
If \`NONE\` is selected, when the input exceeds the maximum input token length an error will be returned.",
                  "type": "optional<ClassifyRequestTruncate>",
                },
              },
            },
            "headers": undefined,
            "name": "ClassifyRequest",
            "query-parameters": undefined,
          },
          "response": {
            "docs": "OK",
            "type": "ClassifyResponse",
          },
        },
        "detokenize": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Detokenize",
          "docs": "This endpoint takes tokens using byte-pair encoding and returns their text representation. To learn more about tokenization and byte pair encoding, see the tokens page.",
          "examples": [
            {
              "name": "Example",
              "request": {
                "tokens": [
                  10104,
                  12221,
                  1315,
                  34,
                  1420,
                  69,
                ],
              },
              "response": {
                "body": {
                  "meta": {
                    "api_version": {
                      "version": "1",
                    },
                    "billed_units": {},
                  },
                  "text": "detokenized! :D",
                },
              },
            },
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const detokenize = await cohere.detokenize({
      tokens: [ 10002, 2261, 2012, 8, 2792, 43 ],
      model: "command",
  });

  console.log(detokenize);
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')

response = co.detokenize(
  tokens=[10104, 12221, 1315, 34, 1420, 69],
  model="command" # optional
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/detokenize",
          "request": {
            "body": {
              "properties": {
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "An optional parameter to provide the model name. This will ensure that the detokenization is done by the tokenizer used by that model.",
                  "type": "optional<string>",
                },
                "tokens": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The list of tokens to be detokenized.",
                  "type": "list<integer>",
                },
              },
            },
            "headers": undefined,
            "name": "DetokenizeRequest",
            "query-parameters": undefined,
          },
          "response": {
            "docs": "OK",
            "type": "DetokenizeResponse",
          },
        },
        "embed": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Embed",
          "docs": "This endpoint returns text embeddings. An embedding is a list of floating point numbers that captures semantic information about the text that it represents.

Embeddings can be used to create text classifiers as well as empower semantic search. To learn more about embeddings, see the embedding page.

If you want to learn more how to use the embedding model, have a look at the [Semantic Search Guide](/docs/semantic-search).",
          "errors": [
            "BadRequestError",
            "InternalServerError",
          ],
          "examples": [
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const embed = await cohere.embed({
      texts: ["hello", "goodbye"],
      model: "embed-english-v3.0",
      inputType: "classification",
  });
  console.log(embed);
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')

response = co.embed(
  texts=['hello', 'goodbye'],
  model='embed-english-v3.0',
  input_type='classification'
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/embed",
          "request": {
            "body": {
              "properties": {
                "embedding_types": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Specifies the types of embeddings you want to get back. Not required and default is None, which returns the Embed Floats response type. Can be one or more of the following types.

* \`"float"\`: Use this when you want to get back the default float embeddings. Valid for all models.
* \`"int8"\`: Use this when you want to get back signed int8 embeddings. Valid for only v3 models.
* \`"uint8"\`: Use this when you want to get back unsigned int8 embeddings. Valid for only v3 models.
* \`"binary"\`: Use this when you want to get back signed binary embeddings. Valid for only v3 models.
* \`"ubinary"\`: Use this when you want to get back unsigned binary embeddings. Valid for only v3 models.",
                  "type": "optional<list<EmbedRequestEmbeddingTypesItem>>",
                },
                "input_type": {
                  "audiences": [
                    "public",
                  ],
                  "docs": undefined,
                  "type": "optional<EmbedInputType>",
                },
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to embed-english-v2.0

The identifier of the model. Smaller "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.

Available models and corresponding embedding dimensions:

* \`embed-english-v3.0\`  1024
* \`embed-multilingual-v3.0\`  1024
* \`embed-english-light-v3.0\`  384
* \`embed-multilingual-light-v3.0\`  384

* \`embed-english-v2.0\`  4096
* \`embed-english-light-v2.0\`  1024
* \`embed-multilingual-v2.0\`  768",
                  "type": "optional<string>",
                },
                "texts": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "An array of strings for the model to embed. Maximum number of texts per call is \`96\`. We recommend reducing the length of each text to be under \`512\` tokens for optimal quality.",
                  "type": "list<string>",
                },
                "truncate": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`NONE|START|END\` to specify how the API will handle inputs longer than the maximum token length.

Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

If \`NONE\` is selected, when the input exceeds the maximum input token length an error will be returned.",
                  "type": "optional<EmbedRequestTruncate>",
                },
              },
            },
            "headers": undefined,
            "name": "EmbedRequest",
            "query-parameters": undefined,
          },
          "response": {
            "docs": "OK",
            "type": "EmbedResponse",
          },
        },
        "generate": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Generate",
          "docs": "This endpoint generates realistic text conditioned on a given input.",
          "errors": [
            "BadRequestError",
            "InternalServerError",
          ],
          "examples": [
            {
              "name": "Example",
              "request": {
                "preset": "my-preset-a58sbd",
                "prompt": "Please explain to me how LLMs work",
                "return_likelihoods": "GENERATION",
                "stream": false,
                "truncate": "NONE",
              },
              "response": {
                "body": {
                  "generations": [],
                  "id": "string",
                  "meta": {
                    "api_version": {
                      "version": "string",
                    },
                    "billed_units": {},
                  },
                },
              },
            },
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const generate = await cohere.generate({
      prompt: "Please explain to me how LLMs work",
  });

  console.log(generate);
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')

response = co.generate(
  prompt='Please explain to me how LLMs work',
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/generate",
          "request": {
            "body": {
              "properties": {
                "end_sequences": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.",
                  "type": "optional<list<string>>",
                },
                "frequency_penalty": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

Using \`frequency_penalty\` in combination with \`presence_penalty\` is not supported on newer models.
",
                  "type": "optional<double>",
                },
                "k": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ensures only the top \`k\` most likely tokens are considered for generation at each step.
Defaults to \`0\`, min value of \`0\`, max value of \`500\`.
",
                  "type": "optional<integer>",
                },
                "logit_bias": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Certain models support the \`logit_bias\` parameter.

Used to prevent the model from generating unwanted tokens or to incentivize it to include desired tokens. The format is \`{token_id: bias}\` where bias is a float between -10 and 10. Tokens can be obtained from text using [Tokenize](/reference/tokenize).

For example, if the value \`{'11': -10}\` is provided, the model will be very unlikely to include the token 11 (\`"\\n"\`, the newline character) anywhere in the generated text. In contrast \`{'11': 10}\` will result in generations that nearly only contain that token. Values between -10 and 10 will proportionally affect the likelihood of the token appearing in the generated text.",
                  "type": "optional<map<string, double>>",
                },
                "max_tokens": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.

Can only be set to \`0\` if \`return_likelihoods\` is set to \`ALL\` to get the likelihood of the prompt.
",
                  "type": "optional<integer>",
                },
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The identifier of the model to generate with. Currently available models are \`command\` (default), \`command-nightly\` (experimental), \`command-light\`, and \`command-light-nightly\` (experimental).
Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.",
                  "type": "optional<string>",
                },
                "num_generations": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The maximum number of generations that will be returned. Defaults to \`1\`, min value of \`1\`, max value of \`5\`.
",
                  "type": "optional<integer>",
                },
                "p": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ensures that only the most likely tokens, with total probability mass of \`p\`, are considered for generation at each step. If both \`k\` and \`p\` are enabled, \`p\` acts after \`k\`.
Defaults to \`0.75\`. min value of \`0.01\`, max value of \`0.99\`.
",
                  "type": "optional<double>",
                },
                "presence_penalty": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`0.0\`, min value of \`0.0\`, max value of \`1.0\`.

Can be used to reduce repetitiveness of generated tokens. Similar to \`frequency_penalty\`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.

Using \`frequency_penalty\` in combination with \`presence_penalty\` is not supported on newer models.
",
                  "type": "optional<double>",
                },
                "preset": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
When a preset is specified, the \`prompt\` parameter becomes optional, and any included parameters will override the preset's parameters.
",
                  "type": "optional<string>",
                },
                "prompt": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The input text that serves as the starting point for generating the response.
Note: The prompt will be pre-processed and modified before reaching the model.
",
                  "type": "string",
                },
                "raw_prompting": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "When enabled, the user's prompt will be sent to the model without any pre-processing.",
                  "type": "optional<boolean>",
                },
                "return_likelihoods": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`GENERATION|ALL|NONE\` to specify how and if the token likelihoods are returned with the response. Defaults to \`NONE\`.

If \`GENERATION\` is selected, the token likelihoods will only be provided for generated text.

If \`ALL\` is selected, the token likelihoods will be provided both for the prompt and the generated text.",
                  "type": "optional<GenerateRequestReturnLikelihoods>",
                },
                "stop_sequences": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.",
                  "type": "optional<list<string>>",
                },
                "stream": {
                  "audiences": [
                    "public",
                  ],
                  "docs": undefined,
                  "type": "literal<false>",
                },
                "temperature": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
Defaults to \`0.75\`, min value of \`0.0\`, max value of \`5.0\`.
",
                  "type": "optional<double>",
                },
                "truncate": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`NONE|START|END\` to specify how the API will handle inputs longer than the maximum token length.

Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

If \`NONE\` is selected, when the input exceeds the maximum input token length an error will be returned.",
                  "type": "optional<GenerateRequestTruncate>",
                },
              },
            },
            "headers": undefined,
            "name": "GenerateRequest",
            "query-parameters": undefined,
          },
          "response": {
            "docs": "",
            "type": "GenerateResponse",
          },
        },
        "generate_stream": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Generate",
          "docs": "This endpoint generates realistic text conditioned on a given input.",
          "errors": [
            "BadRequestError",
            "InternalServerError",
          ],
          "examples": [
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const generate = await cohere.generate({
      prompt: "Please explain to me how LLMs work",
  });

  console.log(generate);
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')

response = co.generate(
  prompt='Please explain to me how LLMs work',
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/generate",
          "request": {
            "body": {
              "properties": {
                "end_sequences": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.",
                  "type": "optional<list<string>>",
                },
                "frequency_penalty": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.

Using \`frequency_penalty\` in combination with \`presence_penalty\` is not supported on newer models.
",
                  "type": "optional<double>",
                },
                "k": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ensures only the top \`k\` most likely tokens are considered for generation at each step.
Defaults to \`0\`, min value of \`0\`, max value of \`500\`.
",
                  "type": "optional<integer>",
                },
                "logit_bias": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Certain models support the \`logit_bias\` parameter.

Used to prevent the model from generating unwanted tokens or to incentivize it to include desired tokens. The format is \`{token_id: bias}\` where bias is a float between -10 and 10. Tokens can be obtained from text using [Tokenize](/reference/tokenize).

For example, if the value \`{'11': -10}\` is provided, the model will be very unlikely to include the token 11 (\`"\\n"\`, the newline character) anywhere in the generated text. In contrast \`{'11': 10}\` will result in generations that nearly only contain that token. Values between -10 and 10 will proportionally affect the likelihood of the token appearing in the generated text.",
                  "type": "optional<map<string, double>>",
                },
                "max_tokens": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.

This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.

Can only be set to \`0\` if \`return_likelihoods\` is set to \`ALL\` to get the likelihood of the prompt.
",
                  "type": "optional<integer>",
                },
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The identifier of the model to generate with. Currently available models are \`command\` (default), \`command-nightly\` (experimental), \`command-light\`, and \`command-light-nightly\` (experimental).
Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.",
                  "type": "optional<string>",
                },
                "num_generations": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The maximum number of generations that will be returned. Defaults to \`1\`, min value of \`1\`, max value of \`5\`.
",
                  "type": "optional<integer>",
                },
                "p": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ensures that only the most likely tokens, with total probability mass of \`p\`, are considered for generation at each step. If both \`k\` and \`p\` are enabled, \`p\` acts after \`k\`.
Defaults to \`0.75\`. min value of \`0.01\`, max value of \`0.99\`.
",
                  "type": "optional<double>",
                },
                "presence_penalty": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Defaults to \`0.0\`, min value of \`0.0\`, max value of \`1.0\`.

Can be used to reduce repetitiveness of generated tokens. Similar to \`frequency_penalty\`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.

Using \`frequency_penalty\` in combination with \`presence_penalty\` is not supported on newer models.
",
                  "type": "optional<double>",
                },
                "preset": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
When a preset is specified, the \`prompt\` parameter becomes optional, and any included parameters will override the preset's parameters.
",
                  "type": "optional<string>",
                },
                "prompt": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The input text that serves as the starting point for generating the response.
Note: The prompt will be pre-processed and modified before reaching the model.
",
                  "type": "string",
                },
                "raw_prompting": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "When enabled, the user's prompt will be sent to the model without any pre-processing.",
                  "type": "optional<boolean>",
                },
                "return_likelihoods": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`GENERATION|ALL|NONE\` to specify how and if the token likelihoods are returned with the response. Defaults to \`NONE\`.

If \`GENERATION\` is selected, the token likelihoods will only be provided for generated text.

If \`ALL\` is selected, the token likelihoods will be provided both for the prompt and the generated text.",
                  "type": "optional<GenerateStreamRequestReturnLikelihoods>",
                },
                "stop_sequences": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.",
                  "type": "optional<list<string>>",
                },
                "stream": {
                  "audiences": [
                    "public",
                  ],
                  "docs": undefined,
                  "type": "literal<true>",
                },
                "temperature": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
Defaults to \`0.75\`, min value of \`0.0\`, max value of \`5.0\`.
",
                  "type": "optional<double>",
                },
                "truncate": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`NONE|START|END\` to specify how the API will handle inputs longer than the maximum token length.

Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

If \`NONE\` is selected, when the input exceeds the maximum input token length an error will be returned.",
                  "type": "optional<GenerateStreamRequestTruncate>",
                },
              },
            },
            "headers": undefined,
            "name": "GenerateStreamRequest",
            "query-parameters": undefined,
          },
          "response-stream": {
            "docs": "",
            "type": "GenerateStreamResponse",
          },
        },
        "rerank": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Rerank",
          "docs": "This endpoint takes in a query and a list of texts and produces an ordered array with each text assigned a relevance score.",
          "examples": [
            {
              "name": "Example",
              "request": {
                "documents": [
                  "Carson City is the capital city of the American state of Nevada.",
                  "The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean. Its capital is Saipan.",
                  "Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States. It is a federal district.",
                  "Capital punishment (the death penalty) has existed in the United States since beforethe United States was a country. As of 2017, capital punishment is legal in 30 of the 50 states.",
                ],
                "model": "rerank-english-v2.0",
                "query": "What is the capital of the United States?",
              },
              "response": {
                "body": {
                  "meta": {
                    "api_version": {
                      "version": "string",
                    },
                    "billed_units": {},
                  },
                  "results": [],
                },
              },
            },
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const rerank = await cohere.rerank({
      documents: [
          { text: "Carson City is the capital city of the American state of Nevada."},
          { text: "The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean. Its capital is Saipan."},
          { text: "Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States. It is a federal district."},
          { text: "Capital punishment (the death penalty) has existed in the United States since beforethe United States was a country. As of 2017, capital punishment is legal in 30 of the 50 states."}
      ],
      query: "What is the capital of the United States?",
      topN: 3,
  });

  console.log(rerank);
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')

docs = ['Carson City is the capital city of the American state of Nevada.',
'The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean. Its capital is Saipan.',
'Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States. It is a federal district.',
'Capital punishment (the death penalty) has existed in the United States since beforethe United States was a country. As of 2017, capital punishment is legal in 30 of the 50 states.']

response = co.rerank(
  model = 'rerank-english-v2.0',
  query = 'What is the capital of the United States?',
  documents = docs,
  top_n = 3,
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/rerank",
          "request": {
            "body": {
              "properties": {
                "documents": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A list of document objects or strings to rerank.
If a document is provided the text fields is required and all other fields will be preserved in the response.

The total max chunks (length of documents * max_chunks_per_doc) must be less than 10000.

We recommend a maximum of 1,000 documents for optimal endpoint performance.",
                  "type": "list<RerankRequestDocumentsItem>",
                },
                "max_chunks_per_doc": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The maximum number of chunks to produce internally from a document",
                  "type": "optional<integer>",
                },
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The identifier of the model to use, one of : \`rerank-english-v2.0\`, \`rerank-multilingual-v2.0\`",
                  "type": "optional<string>",
                },
                "query": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The search query",
                  "type": "string",
                },
                "return_documents": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "- If false, returns results without the doc text - the api will return a list of {index, relevance score} where index is inferred from the list passed into the request.
- If true, returns results with the doc text passed in - the api will return an ordered list of {index, text, relevance score} where index + text refers to the list passed into the request.",
                  "type": "optional<boolean>",
                },
                "top_n": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The number of most relevant documents or indices to return, defaults to the length of the documents",
                  "type": "optional<integer>",
                },
              },
            },
            "headers": undefined,
            "name": "RerankRequest",
            "query-parameters": undefined,
          },
          "response": {
            "docs": "OK",
            "type": "RerankResponse",
          },
        },
        "summarize": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Summarize",
          "docs": "This endpoint generates a summary in English for a given text.",
          "examples": [
            {
              "name": "Example",
              "request": {
                "extractiveness": "low",
                "format": "paragraph",
                "length": "short",
                "text": "Ice cream is a sweetened frozen food typically eaten as a snack or dessert. It may be made from milk or cream and is flavoured with a sweetener, either sugar or an alternative, and a spice, such as cocoa or vanilla, or with fruit such as strawberries or peaches. It can also be made by whisking a flavored cream base and liquid nitrogen together. Food coloring is sometimes added, in addition to stabilizers. The mixture is cooled below the freezing point of water and stirred to incorporate air spaces and to prevent detectable ice crystals from forming. The result is a smooth, semi-solid foam that is solid at very low temperatures (below 2 °C or 35 °F). It becomes more malleable as its temperature increases.

The meaning of the name "ice cream" varies from one country to another. In some countries, such as the United States, "ice cream" applies only to a specific variety, and most governments regulate the commercial use of the various terms according to the relative quantities of the main ingredients, notably the amount of cream. Products that do not meet the criteria to be called ice cream are sometimes labelled "frozen dairy dessert" instead. In other countries, such as Italy and Argentina, one word is used fo
 all variants. Analogues made from dairy alternatives, such as goat's or sheep's milk, or milk substitutes (e.g., soy, cashew, coconut, almond milk or tofu), are available for those who are lactose intolerant, allergic to dairy protein or vegan.",
              },
              "response": {
                "body": {
                  "meta": {
                    "api_version": {
                      "version": "string",
                    },
                    "billed_units": {},
                  },
                },
              },
            },
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const summarize = await cohere.summarize({
      text: "Ice cream is a sweetened frozen food typically eaten as a snack or dessert. "
          + "It may be made from milk or cream and is flavoured with a sweetener, "
          + "either sugar or an alternative, and a spice, such as cocoa or vanilla, "
          + "or with fruit such as strawberries or peaches. "
          + "It can also be made by whisking a flavored cream base and liquid nitrogen together. "
          + "Food coloring is sometimes added, in addition to stabilizers. "
          + "The mixture is cooled below the freezing point of water and stirred to incorporate air spaces "
          + "and to prevent detectable ice crystals from forming. The result is a smooth, "
          + "semi-solid foam that is solid at very low temperatures (below 2 °C or 35 °F). "
          + "It becomes more malleable as its temperature increases.\\n\\n"
          + "The meaning of the name \\"icecream\\" varies from one country to another. "
          + "In some countries, such as the United States, \\"icecream\\" applies only to a specific variety, "
          + "and most governments regulate the commercial use of the various terms according to the "
          + "relative quantities of the main ingredients, notably the amount of cream. "
          + "Products that do not meet the criteria to be called ice cream are sometimes labelled "
          + "\\"frozendairydessert\\" instead. In other countries, such as Italy and Argentina, "
          + "one word is used fo\\r all variants. Analogues made from dairy alternatives, "
          + "such as goat's or sheep's milk, or milk substitutes "
          + "(e.g., soy, cashew, coconut, almond milk or tofu), are available for those who are "
          + "lactose intolerant, allergic to dairy protein or vegan.",
  });

  console.log(summarize);
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')

text=(
  "Ice cream is a sweetened frozen food typically eaten as a snack or dessert. "
  "It may be made from milk or cream and is flavoured with a sweetener, "
  "either sugar or an alternative, and a spice, such as cocoa or vanilla, "
  "or with fruit such as strawberries or peaches. "
  "It can also be made by whisking a flavored cream base and liquid nitrogen together. "
  "Food coloring is sometimes added, in addition to stabilizers. "
  "The mixture is cooled below the freezing point of water and stirred to incorporate air spaces "
  "and to prevent detectable ice crystals from forming. The result is a smooth, "
  "semi-solid foam that is solid at very low temperatures (below 2 °C or 35 °F). "
  "It becomes more malleable as its temperature increases.\\n\\n"
  "The meaning of the name \\"icecream\\" varies from one country to another. "
  "In some countries, such as the United States, \\"icecream\\" applies only to a specific variety, "
  "and most governments regulate the commercial use of the various terms according to the "
  "relative quantities of the main ingredients, notably the amount of cream. "
  "Products that do not meet the criteria to be called ice cream are sometimes labelled "
  "\\"frozendairydessert\\" instead. In other countries, such as Italy and Argentina, "
  "one word is used fo\\r all variants. Analogues made from dairy alternatives, "
  "such as goat's or sheep's milk, or milk substitutes "
  "(e.g., soy, cashew, coconut, almond milk or tofu), are available for those who are "
  "lactose intolerant, allergic to dairy protein or vegan."
)

response = co.summarize(
  text=text,
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/summarize",
          "request": {
            "body": {
              "properties": {
                "additional_command": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "A free-form instruction for modifying how the summaries get generated. Should complete the sentence "Generate a summary _". Eg. "focusing on the next steps" or "written by Yoda"",
                  "type": "optional<string>",
                },
                "extractiveness": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`low\`, \`medium\`, \`high\`, or \`auto\`, defaults to \`auto\`. Controls how close to the original text the summary is. \`high\` extractiveness summaries will lean towards reusing sentences verbatim, while \`low\` extractiveness summaries will tend to paraphrase more. If \`auto\` is selected, the best option will be picked based on the input text.",
                  "type": "optional<SummarizeRequestExtractiveness>",
                },
                "format": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`paragraph\`, \`bullets\`, or \`auto\`, defaults to \`auto\`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If \`auto\` is selected, the best option will be picked based on the input text.",
                  "type": "optional<SummarizeRequestFormat>",
                },
                "length": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "One of \`short\`, \`medium\`, \`long\`, or \`auto\` defaults to \`auto\`. Indicates the approximate length of the summary. If \`auto\` is selected, the best option will be picked based on the input text.",
                  "type": "optional<SummarizeRequestLength>",
                },
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The identifier of the model to generate the summary with. Currently available models are \`command\` (default), \`command-nightly\` (experimental), \`command-light\`, and \`command-light-nightly\` (experimental). Smaller, "light" models are faster, while larger models will perform better.",
                  "type": "optional<string>",
                },
                "temperature": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "Ranges from 0 to 5. Controls the randomness of the output. Lower values tend to generate more “predictable” output, while higher values tend to generate more “creative” output. The sweet spot is typically between 0 and 1.",
                  "type": "optional<double>",
                },
                "text": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The text to generate a summary for. Can be up to 100,000 characters long. Currently the only supported language is English.",
                  "type": "string",
                },
              },
            },
            "headers": undefined,
            "name": "SummarizeRequest",
            "query-parameters": undefined,
          },
          "response": {
            "docs": "OK",
            "type": "SummarizeResponse",
          },
        },
        "tokenize": {
          "audiences": [
            "public",
          ],
          "auth": true,
          "display-name": "Tokenize",
          "docs": "This endpoint splits input text into smaller units called tokens using byte-pair encoding (BPE). To learn more about tokenization and byte pair encoding, see the tokens page.",
          "errors": [
            "BadRequestError",
            "InternalServerError",
          ],
          "examples": [
            {
              "name": "Example",
              "request": {
                "model": "command",
                "text": "tokenize me! :D",
              },
              "response": {
                "body": {
                  "meta": {
                    "api_version": {
                      "version": "1",
                    },
                    "billed_units": {},
                  },
                  "token_strings": [
                    "token",
                    "ize'",
                    " me",
                    "!",
                    " :",
                    "D",
                  ],
                  "tokens": [
                    34160,
                    974,
                    514,
                    34,
                    1420,
                    69,
                  ],
                },
              },
            },
            {
              "code-samples": [
                {
                  "code": "const { CohereClient } = require("cohere-ai");

const cohere = new CohereClient({
    token: "<<apiKey>>",
});

(async () => {
  const tokenize = await cohere.tokenize({
      text: "tokenize me! :D",
      model: "command",
  });

  console.log(tokenize);
})();",
                  "docs": undefined,
                  "install": "npm i cohere-ai",
                  "language": "node",
                  "name": "Cohere TypeScript SDK",
                },
                {
                  "code": "import cohere
co = cohere.Client('<<apiKey>>')

response = co.tokenize(
  text='tokenize me! :D',
  model='command' # optional
)
print(response)",
                  "docs": undefined,
                  "install": "python -m pip install cohere",
                  "language": "python",
                  "name": "Cohere Python SDK",
                },
                {
                  "code": "const cohere = require('cohere-ai');
cohere.init('<<apiKey>>')

(async () => {
  const response = await cohere.tokenize({
    text: 'tokenize me! :D',
    model: 'command' // optional
  });
  console.log(response);
})();",
                  "docs": undefined,
                  "install": "npm install cohere-ai",
                  "language": "node",
                  "name": "Cohere Node.js SDK",
                },
                {
                  "code": "package main

import (
  "fmt"
  cohere "github.com/cohere-ai/cohere-go"
)

func main() {
  co, err := cohere.CreateClient("<<apiKey>>")
  if err != nil {
    fmt.Println(err)
    return
  }

  response, err := co.Tokenize(cohere.TokenizeOptions{
    Text: "tokenize me! :D",
  })
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Println(response)
}",
                  "docs": undefined,
                  "install": "go get github.com/cohere-ai/cohere-go",
                  "language": "go",
                  "name": "Cohere Go SDK",
                },
              ],
            },
          ],
          "method": "POST",
          "path": "/v1/tokenize",
          "request": {
            "body": {
              "properties": {
                "model": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "An optional parameter to provide the model name. This will ensure that the tokenization uses the tokenizer used by that model.",
                  "type": "optional<string>",
                },
                "text": {
                  "audiences": [
                    "public",
                  ],
                  "docs": "The string to be tokenized, the minimum text length is 1 character, and the maximum text length is 65536 characters.",
                  "type": "string",
                },
              },
            },
            "headers": undefined,
            "name": "TokenizeRequest",
            "query-parameters": undefined,
          },
          "response": {
            "docs": "OK",
            "type": "TokenizeResponse",
          },
        },
      },
    },
    "types": {
      "ApiMeta": {
        "docs": undefined,
        "properties": {
          "api_version": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMetaApiVersion>",
          },
          "billed_units": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMetaBilledUnits>",
          },
          "warnings": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<string>>",
          },
        },
      },
      "ApiMetaApiVersion": {
        "docs": undefined,
        "properties": {
          "is_deprecated": {
            "audiences": [
              "public",
            ],
            "type": "optional<boolean>",
          },
          "is_experimental": {
            "audiences": [
              "public",
            ],
            "type": "optional<boolean>",
          },
          "version": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
        },
      },
      "ApiMetaBilledUnits": {
        "docs": undefined,
        "properties": {
          "classifications": {
            "audiences": [
              "public",
            ],
            "docs": "The number of billed classifications units.
",
            "type": "optional<double>",
          },
          "input_tokens": {
            "audiences": [
              "public",
            ],
            "docs": "The number of billed input tokens.
",
            "type": "optional<double>",
          },
          "output_tokens": {
            "audiences": [
              "public",
            ],
            "docs": "The number of billed output tokens.
",
            "type": "optional<double>",
          },
          "search_units": {
            "audiences": [
              "public",
            ],
            "docs": "The number of billed search units.
",
            "type": "optional<double>",
          },
        },
      },
      "AuthTokenType": {
        "docs": "The token_type specifies the way the token is passed in the Authorization header. Valid values are "bearer", "basic", and "noscheme".",
        "enum": [
          "bearer",
          "basic",
          "noscheme",
        ],
      },
      "ChatCitation": {
        "docs": "A section of the generated reply which cites external knowledge.
",
        "properties": {
          "document_ids": {
            "audiences": [
              "public",
            ],
            "docs": "Identifiers of documents cited by this section of the generated reply.
",
            "type": "list<string>",
          },
          "end": {
            "audiences": [
              "public",
            ],
            "docs": "The index of text that the citation ends after, counting from zero. For example, a generation of \`Hello, world!\` with a citation on \`world\` would have an end value of \`11\`. This is because the citation ends after \`d\`, which is the eleventh character.
",
            "type": "integer",
          },
          "start": {
            "audiences": [
              "public",
            ],
            "docs": "The index of text that the citation starts at, counting from zero. For example, a generation of \`Hello, world!\` with a citation on \`world\` would have a start value of \`7\`. This is because the citation starts at \`w\`, which is the seventh character.
",
            "type": "integer",
          },
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "The text of the citation. For example, a generation of \`Hello, world!\` with a citation of \`world\` would have a text value of \`world\`.
",
            "type": "string",
          },
        },
      },
      "ChatCitationGenerationEvent": {
        "docs": undefined,
        "extends": [
          "ChatStreamEvent",
        ],
        "properties": {
          "citations": {
            "audiences": [
              "public",
            ],
            "docs": "Citations for the generated reply.
",
            "type": "list<ChatCitation>",
          },
        },
      },
      "ChatConnector": {
        "docs": "The connector used for fetching documents.
",
        "properties": {
          "continue_on_failure": {
            "audiences": [
              "public",
            ],
            "docs": "An optional override to set whether or not the request continues if this connector fails.
",
            "type": "optional<boolean>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "docs": "The identifier of the connector.
",
            "type": "string",
          },
          "options": {
            "audiences": [
              "public",
            ],
            "docs": "Provides the connector with different settings at request time. The key/value pairs of this object are specific to each connector.

The supported options are:

**web-search**

**site** - The web search results will be restricted to this domain (and TLD) when specified. Only a single domain is specified, and subdomains are also accepted.
Examples:
* \`{"options": {"site": "cohere.com"}}\` would restrict the results to all subdomains at cohere.com
* \`{"options": {"site": "txt.cohere.com"}}\` would restrict the results to \`txt.cohere.com\`
",
            "type": "optional<map<string, unknown>>",
          },
          "user_access_token": {
            "audiences": [
              "public",
            ],
            "docs": "An optional override to set the token that Cohere passes to the connector in the Authorization header.
",
            "type": "optional<string>",
          },
        },
      },
      "ChatDocument": {
        "docs": "Relevant information that could be used by the model to generate a more accurate reply.
The contents of each document are generally short (under 300 words), and are passed in the form of a
dictionary of strings. Some suggested keys are "text", "author", "date". Both the key name and the value will be
passed to the model.
",
        "type": "map<string, string>",
      },
      "ChatMessage": {
        "docs": "A single message in a chat history. Contains the role of the sender, the text contents of the message, and optionally a username.
",
        "properties": {
          "message": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "role": {
            "audiences": [
              "public",
            ],
            "type": "ChatMessageRole",
          },
          "user_name": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
        },
      },
      "ChatMessageRole": {
        "enum": [
          "CHATBOT",
          "USER",
        ],
      },
      "ChatRequestCitationQuality": {
        "docs": "Defaults to \`"accurate"\`.

Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want \`"accurate"\` results or \`"fast"\` results.
",
        "enum": [
          "fast",
          "accurate",
        ],
      },
      "ChatRequestPromptTruncation": {
        "docs": "Defaults to \`AUTO\` when \`connectors\` are specified and \`OFF\` in all other cases.

Dictates how the prompt will be constructed.

With \`prompt_truncation\` set to "AUTO", some elements from \`chat_history\` and \`documents\` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.

With \`prompt_truncation\` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a \`TooManyTokens\` error will be returned.
",
        "enum": [
          "OFF",
          "AUTO",
        ],
      },
      "ChatResponse": {
        "docs": undefined,
        "properties": {
          "citations": {
            "audiences": [
              "public",
            ],
            "docs": "Inline citations for the generated reply.",
            "type": "optional<list<ChatCitation>>",
          },
          "documents": {
            "audiences": [
              "public",
            ],
            "docs": "Documents seen by the model when generating the reply.",
            "type": "optional<list<ChatDocument>>",
          },
          "generation_id": {
            "audiences": [
              "public",
            ],
            "docs": "Unique identifier for the generated reply. Useful for submitting feedback.",
            "type": "string",
          },
          "search_queries": {
            "audiences": [
              "public",
            ],
            "docs": "Generated search queries, meant to be used as part of the RAG flow.",
            "type": "optional<list<ChatSearchQuery>>",
          },
          "search_results": {
            "audiences": [
              "public",
            ],
            "docs": "Documents retrieved from each of the conducted searches.",
            "type": "optional<list<ChatSearchResult>>",
          },
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "Contents of the reply generated by the model.",
            "type": "string",
          },
        },
      },
      "ChatSearchQueriesGenerationEvent": {
        "docs": undefined,
        "extends": [
          "ChatStreamEvent",
        ],
        "properties": {
          "search_queries": {
            "audiences": [
              "public",
            ],
            "docs": "Generated search queries, meant to be used as part of the RAG flow.",
            "type": "list<ChatSearchQuery>",
          },
        },
      },
      "ChatSearchQuery": {
        "docs": "The generated search query. Contains the text of the query and a unique identifier for the query.
",
        "properties": {
          "generation_id": {
            "audiences": [
              "public",
            ],
            "docs": "Unique identifier for the generated search query. Useful for submitting feedback.
",
            "type": "string",
          },
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "The text of the search query.
",
            "type": "string",
          },
        },
      },
      "ChatSearchResult": {
        "docs": undefined,
        "properties": {
          "connector": {
            "audiences": [
              "public",
            ],
            "docs": "The connector from which this result comes from.
",
            "type": "ChatSearchResultConnector",
          },
          "document_ids": {
            "audiences": [
              "public",
            ],
            "docs": "Identifiers of documents found by this search query.
",
            "type": "list<string>",
          },
          "search_query": {
            "audiences": [
              "public",
            ],
            "type": "ChatSearchQuery",
          },
        },
      },
      "ChatSearchResultConnector": {
        "docs": "The connector used for fetching documents.
",
        "properties": {
          "id": {
            "audiences": [
              "public",
            ],
            "docs": "The identifier of the connector.
",
            "type": "string",
          },
        },
      },
      "ChatSearchResultsEvent": {
        "docs": undefined,
        "extends": [
          "ChatStreamEvent",
        ],
        "properties": {
          "documents": {
            "audiences": [
              "public",
            ],
            "docs": "Documents fetched from searches or provided by the user.
",
            "type": "list<ChatDocument>",
          },
          "search_results": {
            "audiences": [
              "public",
            ],
            "docs": "Conducted searches and the ids of documents retrieved from each of them.
",
            "type": "list<ChatSearchResult>",
          },
        },
      },
      "ChatStreamEndEvent": {
        "docs": undefined,
        "extends": [
          "ChatStreamEvent",
        ],
        "properties": {
          "finish_reason": {
            "audiences": [
              "public",
            ],
            "docs": "- \`COMPLETE\` - the model sent back a finished reply
- \`ERROR_LIMIT\` - the reply was cut off because the model reached the maximum number of tokens for its context length
- \`MAX_TOKENS\` - the reply was cut off because the model reached the maximum number of tokens specified by the max_tokens parameter
- \`ERROR\` - something went wrong when generating the reply
- \`ERROR_TOXIC\` - the model generated a reply that was deemed toxic
",
            "type": "ChatStreamEndEventFinishReason",
          },
          "response": {
            "audiences": [
              "public",
            ],
            "docs": "The consolidated response from the model. Contains the generated reply and all the other information streamed back in the previous events.
",
            "type": "ChatStreamEndEventResponse",
          },
        },
      },
      "ChatStreamEndEventFinishReason": {
        "docs": "- \`COMPLETE\` - the model sent back a finished reply
- \`ERROR_LIMIT\` - the reply was cut off because the model reached the maximum number of tokens for its context length
- \`MAX_TOKENS\` - the reply was cut off because the model reached the maximum number of tokens specified by the max_tokens parameter
- \`ERROR\` - something went wrong when generating the reply
- \`ERROR_TOXIC\` - the model generated a reply that was deemed toxic
",
        "enum": [
          "COMPLETE",
          "ERROR_LIMIT",
          "MAX_TOKENS",
          "ERROR",
          "ERROR_TOXIC",
        ],
      },
      "ChatStreamEndEventResponse": {
        "discriminated": false,
        "docs": "The consolidated response from the model. Contains the generated reply and all the other information streamed back in the previous events.
",
        "union": [
          "NonStreamedChatResponse",
          "SearchQueriesOnlyResponse",
        ],
      },
      "ChatStreamEvent": {
        "docs": undefined,
        "properties": {},
      },
      "ChatStreamRequestCitationQuality": {
        "docs": "Defaults to \`"accurate"\`.

Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want \`"accurate"\` results or \`"fast"\` results.
",
        "enum": [
          "fast",
          "accurate",
        ],
      },
      "ChatStreamRequestPromptTruncation": {
        "docs": "Defaults to \`AUTO\` when \`connectors\` are specified and \`OFF\` in all other cases.

Dictates how the prompt will be constructed.

With \`prompt_truncation\` set to "AUTO", some elements from \`chat_history\` and \`documents\` will be dropped in an attempt to construct a prompt that fits within the model's context length limit.

With \`prompt_truncation\` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a \`TooManyTokens\` error will be returned.
",
        "enum": [
          "OFF",
          "AUTO",
        ],
      },
      "ChatStreamResponse": {
        "base-properties": {},
        "discriminant": "event_type",
        "docs": "StreamedChatResponse is returned in streaming mode (specified with \`stream=True\` in the request).",
        "union": {
          "citation-generation": "ChatCitationGenerationEvent",
          "search-queries-generation": "ChatSearchQueriesGenerationEvent",
          "search-results": "ChatSearchResultsEvent",
          "stream-end": "ChatStreamEndEvent",
          "stream-start": "ChatStreamStartEvent",
          "text-generation": "ChatTextGenerationEvent",
        },
      },
      "ChatStreamStartEvent": {
        "docs": undefined,
        "extends": [
          "ChatStreamEvent",
        ],
        "properties": {
          "generation_id": {
            "audiences": [
              "public",
            ],
            "docs": "Unique identifier for the generated reply. Useful for submitting feedback.
",
            "type": "string",
          },
        },
      },
      "ChatTextGenerationEvent": {
        "docs": undefined,
        "extends": [
          "ChatStreamEvent",
        ],
        "properties": {
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "The next batch of text generated by the model.
",
            "type": "string",
          },
        },
      },
      "ClassifyExample": {
        "docs": undefined,
        "properties": {
          "label": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "text": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
        },
      },
      "ClassifyRequestTruncate": {
        "docs": "One of \`NONE|START|END\` to specify how the API will handle inputs longer than the maximum token length.
Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
If \`NONE\` is selected, when the input exceeds the maximum input token length an error will be returned.",
        "enum": [
          "NONE",
          "START",
          "END",
        ],
      },
      "ClassifyResponse": {
        "docs": undefined,
        "properties": {
          "classifications": {
            "audiences": [
              "public",
            ],
            "type": "list<ClassifyResponseClassificationsItem>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
        },
      },
      "ClassifyResponseClassificationsItem": {
        "docs": undefined,
        "properties": {
          "classification_type": {
            "audiences": [
              "public",
            ],
            "docs": "The type of classification performed",
            "type": "ClassifyResponseClassificationsItemClassificationType",
          },
          "confidence": {
            "audiences": [
              "public",
            ],
            "docs": "The confidence score for the top predicted class (only filled for single-label classification)",
            "type": "optional<double>",
          },
          "confidences": {
            "audiences": [
              "public",
            ],
            "docs": "An array containing the confidence scores of all the predictions in the same order",
            "type": "list<double>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "input": {
            "audiences": [
              "public",
            ],
            "docs": "The input text that was classified",
            "type": "optional<string>",
          },
          "labels": {
            "audiences": [
              "public",
            ],
            "docs": "A map containing each label and its confidence score according to the classifier. All the confidence scores add up to 1 for single-label classification. For multi-label classification the label confidences are independent of each other, so they don't have to sum up to 1.",
            "type": "map<string, ClassifyResponseClassificationsItemLabelsValue>",
          },
          "prediction": {
            "audiences": [
              "public",
            ],
            "docs": "The predicted label for the associated query (only filled for single-label models)",
            "type": "optional<string>",
          },
          "predictions": {
            "audiences": [
              "public",
            ],
            "docs": "An array containing the predicted labels for the associated query (only filled for single-label classification)",
            "type": "list<string>",
          },
        },
      },
      "ClassifyResponseClassificationsItemClassificationType": {
        "docs": "The type of classification performed",
        "enum": [
          {
            "name": "SingleLabel",
            "value": "single-label",
          },
          {
            "name": "MultiLabel",
            "value": "multi-label",
          },
        ],
      },
      "ClassifyResponseClassificationsItemLabelsValue": {
        "docs": undefined,
        "properties": {
          "confidence": {
            "audiences": [
              "public",
            ],
            "type": "optional<double>",
          },
        },
      },
      "Cluster": {
        "docs": undefined,
        "properties": {
          "description": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "keywords": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<string>>",
          },
          "sample_elements": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<string>>",
          },
          "size": {
            "audiences": [
              "public",
            ],
            "type": "optional<integer>",
          },
        },
      },
      "Connector": {
        "docs": "A connector allows you to integrate data sources with the '/chat' endpoint to create grounded generations with citations to the data source.
documents to help answer users.",
        "properties": {
          "active": {
            "audiences": [
              "public",
            ],
            "docs": "Whether the connector is active or not.",
            "type": "optional<boolean>",
          },
          "auth_status": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth status for the user making the request. One of ["valid", "expired", ""]. Empty string (field is omitted) means the user has not authorized the connector yet.",
            "type": "optional<ConnectorAuthStatus>",
          },
          "auth_type": {
            "audiences": [
              "public",
            ],
            "docs": "The type of authentication/authorization used by the connector. Possible values: [oauth, service_auth]",
            "type": "optional<string>",
          },
          "continue_on_failure": {
            "audiences": [
              "public",
            ],
            "docs": "Whether a chat request should continue or not if the request to this connector fails.",
            "type": "optional<boolean>",
          },
          "created_at": {
            "audiences": [
              "public",
            ],
            "docs": "The UTC time at which the connector was created.",
            "type": "datetime",
          },
          "description": {
            "audiences": [
              "public",
            ],
            "docs": "A description of the connector.",
            "type": "optional<string>",
          },
          "excludes": {
            "audiences": [
              "public",
            ],
            "docs": "A list of fields to exclude from the prompt (fields remain in the document).",
            "type": "optional<list<string>>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "docs": "The unique identifier of the connector (used in both \`/connectors\` & \`/chat\` endpoints).
This is automatically created from the name of the connector upon registration.",
            "type": "string",
          },
          "name": {
            "audiences": [
              "public",
            ],
            "docs": "A human-readable name for the connector.",
            "type": "string",
          },
          "oauth": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth 2.0 configuration for the connector.",
            "type": "optional<ConnectorOAuth>",
          },
          "organization_id": {
            "audiences": [
              "public",
            ],
            "docs": "The organization to which this connector belongs. This is automatically set to
the organization of the user who created the connector.",
            "type": "optional<string>",
          },
          "updated_at": {
            "audiences": [
              "public",
            ],
            "docs": "The UTC time at which the connector was last updated.",
            "type": "datetime",
          },
          "url": {
            "audiences": [
              "public",
            ],
            "docs": "The URL of the connector that will be used to search for documents.",
            "type": "optional<string>",
          },
        },
      },
      "ConnectorAuthStatus": {
        "docs": "The OAuth status for the user making the request. One of ["valid", "expired", ""]. Empty string (field is omitted) means the user has not authorized the connector yet.",
        "enum": [
          "valid",
          "expired",
        ],
      },
      "ConnectorLog": {
        "docs": undefined,
        "properties": {
          "connector_id": {
            "docs": "Unique identifier for the connector",
            "type": "string",
          },
          "created_at": {
            "docs": "Time of connector log creation in RFC3339 format",
            "type": "datetime",
          },
          "duration_millis": {
            "docs": "Duration of the request in milliseconds",
            "type": "integer",
          },
          "error_message": {
            "docs": "Error message of the request",
            "type": "optional<string>",
          },
          "id": {
            "docs": "Unique identifier for the connector log",
            "type": "string",
          },
          "organization_id": {
            "docs": "Unique identifier for the organization",
            "type": "string",
          },
          "request_id": {
            "docs": "Unique identifier for the request",
            "type": "string",
          },
          "status_code": {
            "docs": "HTTP status code of the request",
            "type": "integer",
          },
          "user_id": {
            "docs": "Unique identifier for the user",
            "type": "string",
          },
        },
      },
      "ConnectorOAuth": {
        "docs": undefined,
        "properties": {
          "authorize_url": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth 2.0 /authorize endpoint to use when users authorize the connector.",
            "type": "string",
          },
          "scope": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth scopes to request when users authorize the connector.",
            "type": "optional<string>",
          },
          "token_url": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth 2.0 /token endpoint to use when users authorize the connector.",
            "type": "string",
          },
        },
      },
      "CreateClusterJobRequest": {
        "docs": undefined,
        "properties": {
          "embeddings_url": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "generate_descriptions": {
            "audiences": [
              "public",
            ],
            "type": "optional<boolean>",
          },
          "input_dataset_id": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "is_deterministic": {
            "audiences": [
              "public",
            ],
            "docs": "Parameter for UMAP. A boolean governing whether the embeddings from UMAP (that will be clustered with HDBSCAN) are deterministic.",
            "type": "optional<boolean>",
          },
          "min_cluster_size": {
            "audiences": [
              "public",
            ],
            "docs": "Defaults to \`10\`. Parameter for HDBSCAN. Only clusters with this number of elements will be returned with a positive cluster number.",
            "type": "optional<integer>",
          },
          "n_neighbors": {
            "audiences": [
              "public",
            ],
            "docs": "Parameter for UMAP. A scalar governing how to balance global vs local structure in the data.",
            "type": "optional<integer>",
          },
          "required": "optional<unknown>",
        },
      },
      "CreateClusterJobResponse": {
        "docs": "Response for creating a cluster job.",
        "properties": {
          "job_id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
        },
      },
      "CreateConnectorOAuth": {
        "docs": undefined,
        "properties": {
          "authorize_url": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth 2.0 /authorize endpoint to use when users authorize the connector.",
            "type": "optional<string>",
          },
          "client_id": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth 2.0 client ID. This fields is encrypted at rest.",
            "type": "optional<string>",
          },
          "client_secret": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth 2.0 client Secret. This field is encrypted at rest and never returned in a response.",
            "type": "optional<string>",
          },
          "scope": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth scopes to request when users authorize the connector.",
            "type": "optional<string>",
          },
          "token_url": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth 2.0 /token endpoint to use when users authorize the connector.",
            "type": "optional<string>",
          },
        },
      },
      "CreateConnectorResponse": {
        "docs": undefined,
        "properties": {
          "connector": "Connector",
        },
      },
      "CreateConnectorServiceAuth": {
        "docs": undefined,
        "properties": {
          "token": {
            "audiences": [
              "public",
            ],
            "docs": "The token that will be used in the HTTP Authorization header when making requests to the connector. This field is encrypted at rest and never returned in a response.",
            "type": "string",
          },
          "type": {
            "audiences": [
              "public",
            ],
            "type": "AuthTokenType",
          },
        },
      },
      "CreateEmbedJobResponse": {
        "docs": "Response from creating an embed job.",
        "properties": {
          "job_id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
        },
      },
      "Dataset": {
        "docs": undefined,
        "properties": {
          "created_at": {
            "audiences": [
              "public",
            ],
            "docs": "The creation date",
            "type": "datetime",
          },
          "dataset_parts": {
            "audiences": [
              "public",
            ],
            "docs": "the underlying files that make up the dataset",
            "type": "optional<list<DatasetPart>>",
          },
          "dataset_type": {
            "audiences": [
              "public",
            ],
            "type": "DatasetType",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "docs": "The dataset ID",
            "type": "string",
          },
          "name": {
            "audiences": [
              "public",
            ],
            "docs": "The name of the dataset",
            "type": "string",
          },
          "parse_info": "optional<ParseInfo>",
          "preserve_fields": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<string>>",
          },
          "required_fields": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<string>>",
          },
          "schema": {
            "audiences": [
              "public",
            ],
            "docs": "the avro schema of the dataset",
            "type": "optional<string>",
          },
          "updated_at": {
            "audiences": [
              "public",
            ],
            "docs": "The last update date",
            "type": "datetime",
          },
          "validation_error": {
            "audiences": [
              "public",
            ],
            "docs": "Errors found during validation",
            "type": "optional<string>",
          },
          "validation_status": {
            "audiences": [
              "public",
            ],
            "type": "DatasetValidationStatus",
          },
          "validation_warnings": {
            "audiences": [
              "public",
            ],
            "docs": "warnings found during validation",
            "type": "optional<list<string>>",
          },
        },
      },
      "DatasetPart": {
        "docs": undefined,
        "properties": {
          "id": {
            "audiences": [
              "public",
            ],
            "docs": "The dataset part ID",
            "type": "string",
          },
          "index": {
            "audiences": [
              "public",
            ],
            "docs": "The index of the file",
            "type": "optional<integer>",
          },
          "name": {
            "audiences": [
              "public",
            ],
            "docs": "The name of the dataset part",
            "type": "string",
          },
          "num_rows": {
            "audiences": [
              "public",
            ],
            "docs": "The number of rows in the file",
            "type": "optional<integer>",
          },
          "original_url": {
            "audiences": [
              "public",
            ],
            "docs": "The download url of the original file",
            "type": "optional<string>",
          },
          "size_bytes": {
            "audiences": [
              "public",
            ],
            "docs": "The size of the file in bytes",
            "type": "optional<integer>",
          },
          "url": {
            "audiences": [
              "public",
            ],
            "docs": "The download url of the file",
            "type": "optional<string>",
          },
        },
      },
      "DatasetType": {
        "docs": "The type of the dataset",
        "enum": [
          {
            "name": "EmbedInput",
            "value": "embed-input",
          },
          {
            "name": "EmbedResult",
            "value": "embed-result",
          },
          {
            "name": "ClusterResult",
            "value": "cluster-result",
          },
          {
            "name": "ClusterOutliers",
            "value": "cluster-outliers",
          },
          {
            "name": "RerankerFinetuneInput",
            "value": "reranker-finetune-input",
          },
          {
            "name": "PromptCompletionFinetuneInput",
            "value": "prompt-completion-finetune-input",
          },
          {
            "name": "SingleLabelClassificationFinetuneInput",
            "value": "single-label-classification-finetune-input",
          },
          {
            "name": "ChatFinetuneInput",
            "value": "chat-finetune-input",
          },
          {
            "name": "MultiLabelClassificationFinetuneInput",
            "value": "multi-label-classification-finetune-input",
          },
        ],
      },
      "DatasetValidationStatus": {
        "docs": "The validation status of the dataset",
        "enum": [
          "unknown",
          "queued",
          "processing",
          "failed",
          "validated",
          "skipped",
        ],
      },
      "DeleteConnectorResponse": "map<string, unknown>",
      "DetokenizeResponse": {
        "docs": undefined,
        "properties": {
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "A string representing the list of tokens.",
            "type": "string",
          },
        },
      },
      "EmbedByTypeResponse": {
        "docs": undefined,
        "properties": {
          "embeddings": {
            "audiences": [
              "public",
            ],
            "docs": "An object with different embedding types. The length of each embedding type array will be the same as the length of the original \`texts\` array.",
            "type": "EmbedByTypeResponseEmbeddings",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "texts": {
            "audiences": [
              "public",
            ],
            "docs": "The text entries for which embeddings were returned.",
            "type": "list<string>",
          },
        },
      },
      "EmbedByTypeResponseEmbeddings": {
        "docs": "An object with different embedding types. The length of each embedding type array will be the same as the length of the original \`texts\` array.",
        "properties": {
          "binary": {
            "audiences": [
              "public",
            ],
            "docs": "An array of packed signed binary embeddings. The length of each binary embedding is 1/8 the length of the float embeddings of the provided model. Each value is between -128 and 127.",
            "type": "optional<list<list<double>>>",
          },
          "float": {
            "audiences": [
              "public",
            ],
            "docs": "An array of float embeddings.",
            "type": "optional<list<list<double>>>",
          },
          "int8": {
            "audiences": [
              "public",
            ],
            "docs": "An array of signed int8 embeddings. Each value is between -128 and 127.",
            "type": "optional<list<list<double>>>",
          },
          "ubinary": {
            "audiences": [
              "public",
            ],
            "docs": "An array of packed unsigned binary embeddings. The length of each binary embedding is 1/8 the length of the float embeddings of the provided model. Each value is between 0 and 255.",
            "type": "optional<list<list<double>>>",
          },
          "uint8": {
            "audiences": [
              "public",
            ],
            "docs": "An array of unsigned int8 embeddings. Each value is between 0 and 255.",
            "type": "optional<list<list<double>>>",
          },
        },
      },
      "EmbedFloatsResponse": {
        "docs": undefined,
        "properties": {
          "embeddings": {
            "audiences": [
              "public",
            ],
            "docs": "An array of embeddings, where each embedding is an array of floats. The length of the \`embeddings\` array will be the same as the length of the original \`texts\` array.",
            "type": "list<list<double>>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "texts": {
            "audiences": [
              "public",
            ],
            "docs": "The text entries for which embeddings were returned.",
            "type": "list<string>",
          },
        },
      },
      "EmbedInputType": {
        "docs": "Specifies the type of input passed to the model. Required for embedding models v3 and higher.

- \`"search_document"\`: Used for embeddings stored in a vector database for search use-cases.
- \`"search_query"\`: Used for embeddings of search queries run against a vector DB to find relevant documents.
- \`"classification"\`: Used for embeddings passed through a text classifier.
- \`"clustering"\`: Used for the embeddings run through a clustering algorithm.
",
        "enum": [
          "search_document",
          "search_query",
          "classification",
          "clustering",
        ],
      },
      "EmbedJob": {
        "docs": undefined,
        "properties": {
          "created_at": {
            "audiences": [
              "public",
            ],
            "docs": "The creation date of the embed job",
            "type": "datetime",
          },
          "input_dataset_id": {
            "audiences": [
              "public",
            ],
            "docs": "ID of the input dataset",
            "type": "string",
          },
          "job_id": {
            "audiences": [
              "public",
            ],
            "docs": "ID of the embed job",
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "model": {
            "audiences": [
              "public",
            ],
            "docs": "ID of the model used to embed",
            "type": "string",
          },
          "name": {
            "audiences": [
              "public",
            ],
            "docs": "The name of the embed job",
            "type": "optional<string>",
          },
          "output_dataset_id": {
            "audiences": [
              "public",
            ],
            "docs": "ID of the resulting output dataset",
            "type": "optional<string>",
          },
          "status": {
            "audiences": [
              "public",
            ],
            "docs": "The status of the embed job",
            "type": "EmbedJobStatus",
          },
          "truncate": {
            "audiences": [
              "public",
            ],
            "docs": "The truncation option used",
            "type": "EmbedJobTruncate",
          },
        },
      },
      "EmbedJobStatus": {
        "docs": "The status of the embed job",
        "enum": [
          "processing",
          "complete",
          "cancelling",
          "cancelled",
          "failed",
        ],
      },
      "EmbedJobTruncate": {
        "docs": "The truncation option used",
        "enum": [
          "START",
          "END",
        ],
      },
      "EmbedRequestEmbeddingTypesItem": {
        "enum": [
          "float",
          "int8",
          "uint8",
          "binary",
          "ubinary",
        ],
      },
      "EmbedRequestTruncate": {
        "docs": "One of \`NONE|START|END\` to specify how the API will handle inputs longer than the maximum token length.

Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

If \`NONE\` is selected, when the input exceeds the maximum input token length an error will be returned.",
        "enum": [
          "NONE",
          "START",
          "END",
        ],
      },
      "EmbedResponse": {
        "base-properties": {},
        "discriminant": "response_type",
        "docs": undefined,
        "union": {
          "embeddings_by_type": "EmbedByTypeResponse",
          "embeddings_floats": "EmbedFloatsResponse",
        },
      },
      "FinishReason": {
        "enum": [
          "COMPLETE",
          "ERROR",
          "ERROR_TOXIC",
          "ERROR_LIMIT",
          "USER_CANCEL",
          "MAX_TOKENS",
        ],
      },
      "GenerateRequestReturnLikelihoods": {
        "docs": "One of \`GENERATION|ALL|NONE\` to specify how and if the token likelihoods are returned with the response. Defaults to \`NONE\`.

If \`GENERATION\` is selected, the token likelihoods will only be provided for generated text.

If \`ALL\` is selected, the token likelihoods will be provided both for the prompt and the generated text.",
        "enum": [
          "GENERATION",
          "ALL",
          "NONE",
        ],
      },
      "GenerateRequestTruncate": {
        "docs": "One of \`NONE|START|END\` to specify how the API will handle inputs longer than the maximum token length.

Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

If \`NONE\` is selected, when the input exceeds the maximum input token length an error will be returned.",
        "enum": [
          "NONE",
          "START",
          "END",
        ],
      },
      "GenerateResponse": {
        "docs": undefined,
        "properties": {
          "generations": {
            "audiences": [
              "public",
            ],
            "docs": "List of generated results",
            "type": "list<SingleGeneration>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "prompt": {
            "audiences": [
              "public",
            ],
            "docs": "Prompt used for generations.",
            "type": "optional<string>",
          },
        },
      },
      "GenerateStreamEnd": {
        "docs": undefined,
        "extends": [
          "GenerateStreamEvent",
        ],
        "properties": {
          "finish_reason": {
            "audiences": [
              "public",
            ],
            "type": "optional<FinishReason>",
          },
          "is_finished": {
            "audiences": [
              "public",
            ],
            "type": "boolean",
          },
          "response": {
            "audiences": [
              "public",
            ],
            "type": "GenerateStreamEndResponse",
          },
        },
      },
      "GenerateStreamEndResponse": {
        "docs": undefined,
        "properties": {
          "generations": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<SingleGenerationInStream>>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "prompt": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
        },
      },
      "GenerateStreamError": {
        "docs": undefined,
        "extends": [
          "GenerateStreamEvent",
        ],
        "properties": {
          "err": {
            "audiences": [
              "public",
            ],
            "docs": "Error message",
            "type": "string",
          },
          "finish_reason": {
            "audiences": [
              "public",
            ],
            "type": "FinishReason",
          },
          "index": {
            "audiences": [
              "public",
            ],
            "docs": "Refers to the nth generation. Only present when \`num_generations\` is greater than zero.",
            "type": "optional<integer>",
          },
          "is_finished": {
            "audiences": [
              "public",
            ],
            "type": "boolean",
          },
        },
      },
      "GenerateStreamEvent": {
        "docs": undefined,
        "properties": {},
      },
      "GenerateStreamRequestReturnLikelihoods": {
        "docs": "One of \`GENERATION|ALL|NONE\` to specify how and if the token likelihoods are returned with the response. Defaults to \`NONE\`.

If \`GENERATION\` is selected, the token likelihoods will only be provided for generated text.

If \`ALL\` is selected, the token likelihoods will be provided both for the prompt and the generated text.",
        "enum": [
          "GENERATION",
          "ALL",
          "NONE",
        ],
      },
      "GenerateStreamRequestTruncate": {
        "docs": "One of \`NONE|START|END\` to specify how the API will handle inputs longer than the maximum token length.

Passing \`START\` will discard the start of the input. \`END\` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.

If \`NONE\` is selected, when the input exceeds the maximum input token length an error will be returned.",
        "enum": [
          "NONE",
          "START",
          "END",
        ],
      },
      "GenerateStreamResponse": {
        "base-properties": {},
        "discriminant": "event_type",
        "docs": "Response in content type stream when \`stream\` is \`true\` in the request parameters. Generation tokens are streamed with the GenerationStream response. The final response is of type GenerationFinalResponse.",
        "union": {
          "stream-end": "GenerateStreamEnd",
          "stream-error": "GenerateStreamError",
          "text-generation": "GenerateStreamText",
        },
      },
      "GenerateStreamText": {
        "docs": undefined,
        "extends": [
          "GenerateStreamEvent",
        ],
        "properties": {
          "index": {
            "docs": "Refers to the nth generation. Only present when \`num_generations\` is greater than zero, and only when text responses are being streamed.",
            "type": "optional<integer>",
          },
          "is_finished": "boolean",
          "text": {
            "docs": "A segment of text of the generation.",
            "type": "string",
          },
        },
      },
      "GenerateStreamedResponse": {
        "base-properties": {},
        "discriminant": "event_type",
        "docs": "Response in content type stream when \`stream\` is \`true\` in the request parameters. Generation tokens are streamed with the GenerationStream response. The final response is of type GenerationFinalResponse.",
        "union": {
          "stream-end": "GenerateStreamEnd",
          "stream-error": "GenerateStreamError",
          "text-generation": "GenerateStreamText",
        },
      },
      "Generation": {
        "docs": undefined,
        "properties": {
          "generations": {
            "audiences": [
              "public",
            ],
            "docs": "List of generated results",
            "type": "list<SingleGeneration>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "prompt": {
            "audiences": [
              "public",
            ],
            "docs": "Prompt used for generations.",
            "type": "optional<string>",
          },
        },
      },
      "GetClusterJobResponse": {
        "docs": "Response for getting a cluster job.",
        "properties": {
          "clusters": {
            "audiences": [
              "public",
            ],
            "docs": "The list of cluster summaries for the job",
            "type": "optional<list<Cluster>>",
          },
          "created_at": {
            "audiences": [
              "public",
            ],
            "docs": "Time of job creation in RFC3339 format",
            "type": "optional<datetime>",
          },
          "embeddings_url": {
            "audiences": [
              "public",
            ],
            "docs": "The input file URL used for the job",
            "type": "optional<string>",
          },
          "error": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "input_dataset_id": {
            "audiences": [
              "public",
            ],
            "docs": "The input dataset ID used for the job",
            "type": "optional<string>",
          },
          "is_deterministic": {
            "audiences": [
              "public",
            ],
            "docs": "The parameter used in the job creation. Please refer to the job creation endpoint for more details",
            "type": "optional<boolean>",
          },
          "is_final_state": {
            "audiences": [
              "public",
            ],
            "docs": "A boolean indicating whether the job is in a final state, whether completed or failed",
            "type": "optional<boolean>",
          },
          "job_id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "min_cluster_size": {
            "audiences": [
              "public",
            ],
            "docs": "The parameter used in the job creation. Please refer to the job creation endpoint for more details",
            "type": "optional<integer>",
          },
          "n_neighbors": {
            "audiences": [
              "public",
            ],
            "docs": "The parameter used in the job creation. Please refer to the job creation endpoint for more details",
            "type": "optional<integer>",
          },
          "output_clusters_url": {
            "audiences": [
              "public",
            ],
            "docs": "The output file URL for the clusters (signed url that expires)",
            "type": "optional<string>",
          },
          "output_outliers_url": {
            "audiences": [
              "public",
            ],
            "docs": "The output file URL for the outliers (signed url that expires)",
            "type": "optional<string>",
          },
          "status": {
            "audiences": [
              "public",
            ],
            "type": "optional<GetClusterJobResponseStatus>",
          },
        },
      },
      "GetClusterJobResponseStatus": {
        "enum": [
          "unknown",
          "processing",
          "failed",
          "complete",
          "queued",
        ],
      },
      "GetConnectorResponse": {
        "docs": undefined,
        "properties": {
          "connector": "Connector",
        },
      },
      "GetConnectorsLogsResponse": {
        "docs": undefined,
        "properties": {
          "connector_logs": "list<ConnectorLog>",
          "total": {
            "docs": "Total number of connector logs",
            "type": "double",
          },
        },
      },
      "ListClusterJobsResponse": {
        "docs": undefined,
        "properties": {
          "jobs": {
            "audiences": [
              "public",
            ],
            "type": "list<GetClusterJobResponse>",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "total_count": {
            "audiences": [
              "public",
            ],
            "type": "optional<integer>",
          },
        },
      },
      "ListConnectorsResponse": {
        "docs": undefined,
        "properties": {
          "connectors": {
            "audiences": [
              "public",
            ],
            "type": "list<Connector>",
          },
        },
      },
      "ListEmbedJobResponse": {
        "docs": undefined,
        "properties": {
          "embed_jobs": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<EmbedJob>>",
          },
        },
      },
      "LogLikelihoodResponse": {
        "docs": undefined,
        "properties": {
          "completion_tokens": {
            "audiences": [
              "public",
            ],
            "docs": "Probabilities for tokens in the request completion",
            "type": "list<TokenLikelihood>",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "prompt_tokens": {
            "audiences": [
              "public",
            ],
            "docs": "Probabilities for tokens in the request prompt",
            "type": "list<TokenLikelihood>",
          },
          "raw_prompt_tokens": {
            "audiences": [
              "public",
            ],
            "docs": "Probabilities for tokens in the request raw_prompt",
            "type": "list<TokenLikelihood>",
          },
        },
      },
      "ModelConfig": {
        "docs": undefined,
        "properties": {
          "additional_languages": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "baseline_model": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "billing_model_name": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "compatibility_version": {
            "audiences": [
              "public",
            ],
            "type": "optional<integer>",
          },
          "compatible_endpoints": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<string>>",
          },
          "compression_values": {
            "audiences": [
              "public",
            ],
            "type": "optional<map<string, double>>",
          },
          "context_length": {
            "audiences": [
              "public",
            ],
            "type": "optional<integer>",
          },
          "default_language": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "end_of_sequence_string": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "endpoint_type": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "finetune_id": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "group": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "is_baseline": {
            "audiences": [
              "public",
            ],
            "type": "optional<boolean>",
          },
          "labels": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<string>>",
          },
          "model_id": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "model_size": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "model_type": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "model_url": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "model_version": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "multi_label": {
            "audiences": [
              "public",
            ],
            "type": "optional<boolean>",
          },
          "name": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "nemo_model_id": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "prompt_templates": {
            "audiences": [
              "public",
            ],
            "type": "optional<map<string, string>>",
          },
          "route": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "serving_entrypoint": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "serving_framework": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "streaming": {
            "audiences": [
              "public",
            ],
            "type": "optional<boolean>",
          },
          "tokenizer_id": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
        },
      },
      "NonStreamedChatResponse": {
        "docs": undefined,
        "properties": {
          "citations": {
            "audiences": [
              "public",
            ],
            "docs": "Inline citations for the generated reply.",
            "type": "optional<list<ChatCitation>>",
          },
          "documents": {
            "audiences": [
              "public",
            ],
            "docs": "Documents seen by the model when generating the reply.",
            "type": "optional<list<ChatDocument>>",
          },
          "generation_id": {
            "audiences": [
              "public",
            ],
            "docs": "Unique identifier for the generated reply. Useful for submitting feedback.",
            "type": "string",
          },
          "search_queries": {
            "audiences": [
              "public",
            ],
            "docs": "Generated search queries, meant to be used as part of the RAG flow.",
            "type": "optional<list<ChatSearchQuery>>",
          },
          "search_results": {
            "audiences": [
              "public",
            ],
            "docs": "Documents retrieved from each of the conducted searches.",
            "type": "optional<list<ChatSearchResult>>",
          },
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "Contents of the reply generated by the model.",
            "type": "string",
          },
        },
      },
      "OAuthAuthorizeResponse": {
        "docs": undefined,
        "properties": {
          "redirect_url": {
            "audiences": [
              "public",
            ],
            "docs": "The OAuth 2.0 redirect url. Redirect the user to this url to authorize the connector.",
            "type": "optional<string>",
          },
        },
      },
      "ParseInfo": {
        "docs": undefined,
        "properties": {
          "delimiter": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "separator": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
        },
      },
      "RerankRequestDocumentsItem": {
        "discriminated": false,
        "docs": undefined,
        "union": [
          "string",
          "RerankRequestDocumentsItemText",
        ],
      },
      "RerankRequestDocumentsItemText": {
        "docs": undefined,
        "properties": {
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "The text of the document to rerank.",
            "type": "string",
          },
        },
      },
      "RerankResponse": {
        "docs": undefined,
        "properties": {
          "id": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "results": {
            "audiences": [
              "public",
            ],
            "docs": "An ordered list of ranked documents",
            "type": "list<RerankResponseResultsItem>",
          },
        },
      },
      "RerankResponseResultsItem": {
        "docs": undefined,
        "properties": {
          "document": {
            "audiences": [
              "public",
            ],
            "docs": "The doc object which was ranked",
            "type": "optional<RerankResponseResultsItemDocument>",
          },
          "index": {
            "audiences": [
              "public",
            ],
            "docs": "The index of the input document",
            "type": "integer",
          },
          "relevance_score": {
            "audiences": [
              "public",
            ],
            "docs": "A relevance score assigned to the ranking",
            "type": "double",
          },
        },
      },
      "RerankResponseResultsItemDocument": {
        "docs": "The doc object which was ranked",
        "properties": {
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "The text of the document to rerank",
            "type": "string",
          },
        },
      },
      "SearchQueriesOnlyResponse": {
        "docs": undefined,
        "properties": {
          "search_queries": {
            "audiences": [
              "public",
            ],
            "docs": "Generated search queries, meant to be used as part of the RAG flow.",
            "type": "list<ChatSearchQuery>",
          },
        },
      },
      "SingleGeneration": {
        "docs": undefined,
        "properties": {
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "index": {
            "audiences": [
              "public",
            ],
            "docs": "Refers to the nth generation. Only present when \`num_generations\` is greater than zero.",
            "type": "optional<integer>",
          },
          "likelihood": {
            "audiences": [
              "public",
            ],
            "type": "optional<double>",
          },
          "text": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "token_likelihoods": {
            "audiences": [
              "public",
            ],
            "docs": "Only returned if \`return_likelihoods\` is set to \`GENERATION\` or \`ALL\`. The likelihood refers to the average log-likelihood of the entire specified string, which is useful for [evaluating the performance of your model](likelihood-eval), especially if you've created a [custom model](/docs/training-custom-models). Individual token likelihoods provide the log-likelihood of each token. The first token will not have a likelihood.",
            "type": "optional<list<SingleGenerationTokenLikelihoodsItem>>",
          },
        },
      },
      "SingleGenerationInStream": {
        "docs": undefined,
        "properties": {
          "finish_reason": {
            "audiences": [
              "public",
            ],
            "type": "FinishReason",
          },
          "id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
          "index": {
            "audiences": [
              "public",
            ],
            "docs": "Refers to the nth generation. Only present when \`num_generations\` is greater than zero.",
            "type": "optional<integer>",
          },
          "text": {
            "audiences": [
              "public",
            ],
            "docs": "Full text of the generation.",
            "type": "string",
          },
        },
      },
      "SingleGenerationTokenLikelihoodsItem": {
        "docs": undefined,
        "properties": {
          "likelihood": {
            "audiences": [
              "public",
            ],
            "type": "double",
          },
          "token": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
        },
      },
      "StreamedChatResponse": {
        "base-properties": {},
        "discriminant": "event_type",
        "docs": "StreamedChatResponse is returned in streaming mode (specified with \`stream=True\` in the request).",
        "union": {
          "citation-generation": "ChatCitationGenerationEvent",
          "search-queries-generation": "ChatSearchQueriesGenerationEvent",
          "search-results": "ChatSearchResultsEvent",
          "stream-end": "ChatStreamEndEvent",
          "stream-start": "ChatStreamStartEvent",
          "text-generation": "ChatTextGenerationEvent",
        },
      },
      "SummarizeRequestExtractiveness": {
        "docs": "One of \`low\`, \`medium\`, \`high\`, or \`auto\`, defaults to \`auto\`. Controls how close to the original text the summary is. \`high\` extractiveness summaries will lean towards reusing sentences verbatim, while \`low\` extractiveness summaries will tend to paraphrase more. If \`auto\` is selected, the best option will be picked based on the input text.",
        "enum": [
          "low",
          "medium",
          "high",
        ],
      },
      "SummarizeRequestFormat": {
        "docs": "One of \`paragraph\`, \`bullets\`, or \`auto\`, defaults to \`auto\`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If \`auto\` is selected, the best option will be picked based on the input text.",
        "enum": [
          "paragraph",
          "bullets",
        ],
      },
      "SummarizeRequestLength": {
        "docs": "One of \`short\`, \`medium\`, \`long\`, or \`auto\` defaults to \`auto\`. Indicates the approximate length of the summary. If \`auto\` is selected, the best option will be picked based on the input text.",
        "enum": [
          "short",
          "medium",
          "long",
        ],
      },
      "SummarizeResponse": {
        "docs": undefined,
        "properties": {
          "id": {
            "audiences": [
              "public",
            ],
            "docs": "Generated ID for the summary",
            "type": "optional<string>",
          },
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "summary": {
            "audiences": [
              "public",
            ],
            "docs": "Generated summary for the text",
            "type": "optional<string>",
          },
        },
      },
      "TokenLikelihood": {
        "docs": undefined,
        "properties": {
          "decoded": {
            "audiences": [
              "public",
            ],
            "docs": "Detokenized text",
            "type": "optional<string>",
          },
          "encoded": {
            "audiences": [
              "public",
            ],
            "docs": "Tokenized text",
            "type": "optional<integer>",
          },
          "log_likelihood": {
            "audiences": [
              "public",
            ],
            "docs": "Non normalized probability of the token",
            "type": "optional<double>",
          },
        },
      },
      "TokenizeResponse": {
        "docs": undefined,
        "properties": {
          "meta": {
            "audiences": [
              "public",
            ],
            "type": "optional<ApiMeta>",
          },
          "token_strings": {
            "audiences": [
              "public",
            ],
            "type": "list<string>",
          },
          "tokens": {
            "audiences": [
              "public",
            ],
            "docs": "An array of tokens, where each token is an integer.",
            "type": "list<integer>",
          },
        },
      },
      "UpdateClusterJobRequest": {
        "docs": undefined,
        "properties": {
          "clusters": {
            "audiences": [
              "public",
            ],
            "type": "optional<list<Cluster>>",
          },
          "error": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "input_tracking_metrics": {
            "audiences": [
              "public",
            ],
            "type": "optional<map<string, unknown>>",
          },
          "output_clusters_gs_path": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "output_outliers_gs_path": {
            "audiences": [
              "public",
            ],
            "type": "optional<string>",
          },
          "output_tracking_metrics": {
            "audiences": [
              "public",
            ],
            "type": "optional<map<string, unknown>>",
          },
          "status": {
            "audiences": [
              "public",
            ],
            "type": "optional<UpdateClusterJobRequestStatus>",
          },
        },
      },
      "UpdateClusterJobRequestStatus": {
        "enum": [
          "unknown",
          "processing",
          "failed",
          "complete",
          "queued",
        ],
      },
      "UpdateClusterJobResponse": {
        "docs": "Response for updating a cluster job.",
        "properties": {
          "job_id": {
            "audiences": [
              "public",
            ],
            "type": "string",
          },
        },
      },
      "UpdateConnectorResponse": {
        "docs": undefined,
        "properties": {
          "connector": "Connector",
        },
      },
    },
  },
  "rootApiFile": {
    "auth": "BearerAuthScheme",
    "auth-schemes": {
      "BearerAuthScheme": {
        "scheme": "bearer",
      },
    },
    "default-environment": "Production",
    "display-name": "API Reference",
    "environments": {
      "Production": "https://api.cohere.ai",
    },
    "error-discrimination": {
      "strategy": "status-code",
    },
    "headers": {
      "X-Client-Name": {
        "docs": "The name of the project that is making the request.
",
        "name": "clientName",
        "type": "optional<string>",
      },
    },
    "name": "api",
  },
}
`;
